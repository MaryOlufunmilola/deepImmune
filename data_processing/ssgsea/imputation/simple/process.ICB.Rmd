---
title: "R Notebook"
output: html_notebook
---


## Running individual phenotype. 

```{r}
# CUDA_VISIBLE_DEVICES=3 python train.py  --data_dir  ~/project/deeplearning/icb/data/tcga/tf/binarize/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/tcga/tf/binarize/.  --tensorboard_prefix surv_noaug_bin_ --hyper_param "params.add_noise=0"
# 
# 
col.names = colnames(fread("~/project/deeplearning/icb/data/tcga/tf/binarize/dataset_val.txt",nrows = 1))
start = 4001 + 244 -2
pheno.all.inx = 4001 + 244:438
pheno.type = c(rep("continuous", 400-244 +1), rep("binary",430-401+1), rep( "survival",438-431+1))
pheno.next = start+1
pheno.last.index = pheno.all.inx[length(pheno.all.inx)]
commands = list()
cuda.id = 0
while(pheno.next < pheno.last.index){
    label.curr = paste0("Pheno_",pheno.next, "_", col.names[pheno.next], "_")
    if (pheno.type[pheno.next - start] == "continuous"){
        pheno.str=sprintf("continuous_phenotype_indices=[%d]", pheno.next-2)
        pheno.next = pheno.next + 1
    }else if (pheno.type[pheno.next - start] == "binary"){
        pheno.str=sprintf("binary_phenotype_indices=[%d]", pheno.next-2)
        pheno.next = pheno.next + 1
    }else if(pheno.type[pheno.next - start]=="survival"){
        pheno.str=sprintf("survival_indices=[%d, %d]", pheno.next-2, pheno.next-2+1)
        pheno.next = pheno.next + 2
    }
    commands[[label.curr]] = sprintf("CUDA_VISIBLE_DEVICES=%d python train.py  --data_dir  ~/project/deeplearning/icb/data/tcga/tf/binarize/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/tcga/tf/binarize/.  --tensorboard_prefix %s --hyper_param \"params.%s\"",cuda.id, label.curr, pheno.str)
    cuda.id = (cuda.id +1) %% 4
    
}


library(parallel)
# Using fork()
mc.cores = 16 
out = list()
for (ii in seq(ceiling(length(commands)/mc.cores))) {
    last.task.in.itr = min(length(commands), mc.cores * (ii))
    tasks.curr = commands[(mc.cores * (ii-1) +1 ): last.task.in.itr] 
    print(sprintf("running commands %d", last.task.in.itr))
    # print(tasks.curr)
    out[[ii]] <- mclapply(tasks.curr, function(tt) system(c(unlist(tt)),intern =  T),
                          mc.cores = mc.cores)
    # out <- mclapply(tasks.curr, function(tt) c(unlist(tt)),
    # mc.cores = mc.cores, mc.cleanup=TRUE)
}
```

```{r}
create.deepImmune.dataset <- function( expression.file, followup.file, genes.curr) {
    aa = fread(expression.file)
    bb = fread(followup.file)
    genes.inx = match(genes.curr, aa$Symbol)
    patient.curr = intersect(bb$Patient, colnames(aa))
    patient.inx = match(patient.curr, colnames(aa))
    exp.mat = t(aa[genes.inx, patient.inx, with=F]) 
    pheno.mat =  bb[match(patient.curr, Patient), -1,with=F]
    list(sample=patient.curr, exp=exp.mat, pheno=pheno.mat)
}

create.deepImmune.input <- function(output.dir, expression.file,  genes.curr) {
    aa = fread(expression.file)
    genes.inx = match(genes.curr, aa$Symbol)
    exp.mat = as.matrix(t(aa[genes.inx,-1,with=F]) )
    colnames(exp.mat) = genes.curr
    exp.mat
}
```


```{r, eval=FALSE}
expression.file="~/liulab_home/data/ssgsea/xiaoman/icb/expression/Gide2019_PD1+CTLA4_Melanoma_RNASeq"
followup.file="~/liulab_home/data/ssgsea/xiaoman/icb/follow_up/Gide2019_PD1+CTLA4_Melanoma_RNASeq"
dataset.curr = create.deepImmune.dataset(expression.file = expression.file, followup.file = followup.file, genes.curr=genes.analyzed)
```


```{r}
expression.files = list.files(path = "~/liulab_home/data/ssgsea/xiaoman/icb/expression/", full.names = T)
load("~/project/deeplearning/icb/data/tcga/tf/genes.analyzed.RData")
dataset.exp.only =  sapply( expression.files, function(expression.file) create.deepImmune.input(expression.file = expression.file,  genes.curr=genes.analyzed), USE.NAMES = T)
dataset.name = sapply(expression.files, basename)
expression.dataset.patinet.name = lapply(dataset.exp.only, rownames)
names(expression.dataset.patinet.name) = dataset.name
all.expression = do.call(rbind, dataset.exp.only)
dataset.label = sapply(seq(length(dataset.exp.only)), function(tt) rep(tt, nrow(dataset.exp.only[[tt]])))
```


```{r}
cancertype = unlist(dataset.label)
all.icb.dataset = data.table(cbind(cancertype, all.expression))
output.dir = "~/project/deeplearning/icb/data/icb/tf"
write.dataset(output.dir = output.dir, dataset = all.icb.dataset, sample.name = rownames(all.expression))
file.copy("~/project/deeplearning/icb/data/tcga/tf/binarize/params.json", output.dir)
file.copy("~/project/deeplearning/icb/data/tcga/tf/binarize/datasets_tsne_list.txt", output.dir)
file.copy("~/project/deeplearning/icb/data/tcga/tf/binarize/datasets_test_list.txt", output.dir)

```
## running the icb data for each phenotype

```{r}
# python evaluate.py  --data_dir  %s/datasets_test_list.txt --model_dir %s/.  --restore_file %s/last.pth.tar  --output_dir $PATH/all.icb/
# 
# 
model_dirs =list.files(path = "/homes6/asahu/project/deeplearning/icb/data/tcga/tf/binarize/./tensorboardLog/", full.names = T, pattern = "^Pheno_")
data_dir = "/homes6/asahu/project/deeplearning/icb/data/icb/tf/"
for (model_dir in model_dirs) {
    label = basename(model_dir)
    hyper.params = readLines(paste0(model_dir,"/","hyper_param.txt"),warn=F)
    command = sprintf("python evaluate.py  --data_dir  %s/datasets_test_list.txt --model_dir %s/.  --restore_file %s/best.pth.tar  --output_dir %s/all.icb/ --hyper_param %s", data_dir, model_dir, model_dir, model_dir, hyper.params)
    system(command,intern =  T)
}
```


```{r}
## reading result for each phenotype
icb.predicted = list()
for (model_dir in model_dirs) {
    label = basename(model_dir)
    outp = fread(sprintf("%s/all.icb/val_0_prediction.csv", model_dir))
    icb.predicted[[label]] = outp[,seq(ncol(outp)-4, ncol(outp)),with=F]
}
phenotypes.predicted = do.call( cbind, lapply(icb.predicted, function(tt) tt[[1]]))
embedding.predicted = do.call( cbind, lapply(icb.predicted, function(tt) as.matrix(tt[,2:5,with=F])))

```


## evaluate ICB response 
```{r}
## First only using immune phenotypes 
## Then use emebedding 
## both response information and survival info. 


## match ICB patients for which response information is there
## 
followups = sapply(list.files(path = "~/liulab_home/data/ssgsea/xiaoman/icb/follow_up/", full.names = T), fread, USE.NAMES = TRUE)
dataset.name = sapply(list.files(path = "~/liulab_home/data/ssgsea/xiaoman/icb/expression/", full.names = T), basename)
meta.info.dt = do.call(rbind, lapply(dataset.name, function(tt) data.table(Patient=expression.dataset.patinet.name[[tt]], names=tt)))
meta.info.dt$inx = seq(nrow(meta.info.dt))
meta.info.dt[,label:=paste(Patient, names)]
names(followups) = sapply(names(followups), basename)
sapply(followups, function(tt) setnames(tt, 1, "Patient"))
```


## calculate AUC matrix
```{r}
icb.phenotypes.aucs = sapply(dataset.name, function(tt){
    meta.info.curr = meta.info.dt[names==tt]
    followups.curr = followups[[tt]]
    setnames(followups.curr,1, "Patient")
    intersect.patient = intersect(meta.info.curr$Patient, followups.curr$Patient)
    meta.info.matched = meta.info.curr[match(intersect.patient,Patient)]
    phenotype.matched = phenotypes.predicted[meta.info.matched$inx,]
    response.curr = followups.curr[match(intersect.patient,Patient)]$Response
    apply(phenotype.matched, 2, function(uu) tryCatch(pROC::auc(response.curr, uu, quiet=T), error = function(e) NA))
})

phenotype.name = sapply(rownames(icb.phenotypes.aucs), function(tt) {
    strlen = nchar(tt)
    end = 12 + min(c(12, strlen-28))
    substring(tt,12, end)
})
colnames(icb.phenotypes.aucs) = dataset.name
rownames(icb.phenotypes.aucs) = phenotype.name


dat = icb.phenotypes.aucs
xx = cor(dat, method = "spearman", use = "pairwise.complete.obs"); xx[is.na(xx)] = 0
hc = hclust(as.dist(1 - abs(xx)), method = "complete")
M = xx[order.dendrogram(as.dendrogram(hc)), order.dendrogram(as.dendrogram(hc))]
xx = cor(t(dat), method = "spearman", use = "pairwise.complete.obs"); xx[is.na(xx)] = 0
hr = hclust(as.dist(1 - abs(xx)), method = "complete")

# require(heatmap3)
# pdf("~/temp.pdf")
# heatmap(dat, Rowv = as.dendrogram(hr), Colv = as.dendrogram(hc), 
#         scale = "col", balanceColor = T, showRowDendro = F, showColDendro = F, 
#         cexRow = 0.5, cexCol = 0.5)
# dev.off()
# pheatmap(dat[,-ncol(dat)],show_rownames = F)
out =  t(dat[,-ncol(dat)])
out = out[, apply(out,2,max) > 0.81]
out = out[,order(apply(out, 2, median))]
library(pheatmap)
pheatmap(out, cluster_cols = F,fontsize_col = 5, filename=".figs/icb.from.tcga.pheno.pdf", width = 10, height = 10)
out[,grep("SMARCC2", colnames(out))]
out[,grep("time", colnames(out))]

out.dt = data.table(melt(out))

label.sel = which((apply(out, 2, median)> 0.625))
library(scales)
p = ggplot(out.dt[Var2 %in% names(label.sel)],aes(y=value, x=as.factor(Var2))) + geom_bar(aes(fill=as.factor(Var1)),stat = "identity", position=position_dodge()) +
    scale_y_continuous(limits=c(0.4,1),oob = rescale_none)  + coord_flip()
ggsave(filename = "~/Rplot.pdf", p,  width=7, height=10)
```
## finetune neoantigen genentech data. 

```{r}
# --model_dir ~/project/deeplearning/icb/data/tcga/tf/binarize/.  --tensorboard_prefix %s --hyper_param \"params.%s\"",cuda.id, label.curr, pheno.str)
## finetune neoantigen
python train.py  --data_dir  ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/.  --restore_file ~/project/deeplearning/icb/data/tcga/tf//binarize/tensorboardLog/Pheno_4283_SNV.Neoantigens_20200223-030456/best.pth.tar --hyper_param "params.continuous_phenotype_indices=[4281]" --tensorboard_prefix "Pheno_4283_SNV.Neoantigens_20200223-030456_"


python evaluate.py  --data_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/datasets_eval_list.txt --model_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/.  --restore_file ~/project/deeplearning/icb/data/tcga/tf//binarize/tensorboardLog/Pheno_4283_SNV.Neoantigens_20200223-030456/best.pth.tar --hyper_param "params.continuous_phenotype_indices=[4281]"   --output_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/val

python evaluate.py  --data_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/datasets_test_list.txt --model_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/.  --restore_file ~/project/deeplearning/icb/data/tcga/tf//binarize/tensorboardLog/Pheno_4283_SNV.Neoantigens_20200223-030456/best.pth.tar --hyper_param "params.continuous_phenotype_indices=[4281]"   --output_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/all


## survival 
python train.py  --data_dir  ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/.  --restore_file ~/project/deeplearning/icb/data/tcga/tf//binarize/tensorboardLog/Pheno_4433_PFI.time_20200224-123843/best.pth.tar --hyper_param "params.survival_indices=[4429, 4430]; params.learning_rate=1e-7" --tensorboard_prefix "Pheno_4433_PFI.time_20200224-123843_"


```

```{r}
val = fread("~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/val/val_0_prediction.csv")
val1 = fread("/homes6/asahu/project/deeplearning/icb/data/genentech.tpm/tf/binarize/tensorboardLog/Pheno_4283_SNV.Neoantigens_20200223-030456_20200228-114655/best_val_0.csv")

val12 = fread("~/project/deeplearning/icb/data/genentech.tpm/tf/binarize/all/val_0_prediction.csv")

create.plot = function(val){
    aa = cor.test(val$SNV.Neoantigens, val$SNV.Neoantigens.output, method="spearman")
    library(ggplot2)
    library(ggpubr)
    p1  = ggplot(val, aes(x=rank(SNV.Neoantigens), y=rank(SNV.Neoantigens.output))) + geom_point() + ggtitle(sprintf("Coef=%f, P=%f", aa$estimate, aa$p.value))
    p1
}

p2 = create.plot(val1)
p3 = create.plot(val12)

## genentech.pheno.matched is from process.all.dataset.Rmd
pp3  = ggplot(val12, aes(x=rank(SNV.Neoantigens), y=rank(SNV.Neoantigens.output))) + geom_point(aes(color=as.factor(genentech.pheno.matched$Met.Disease.Status))) + ggtitle(sprintf("Coef=%f, P=%f", aa$estimate, aa$p.value))
pp3
```



I think the single cell data could be leverage to train a deep learning model. Tumor immune micro-envrionment composed of different immune cells and cancer cells. This composisition decides whether patient responds to immunotherapy. A key question is if a tumor is immune-supressive then i) if immune composition makes the TIME immune-suppressive, or (ii) cancer cells explicitly modulately TIME, e.g. making TIME hypoxic, or (iii) certain immune cells are dysregulated, or (iv) immune-response is a stochastic phenomenon. 

Remind yourself : (a) certain cancer-type does not respond to immunotherapy at all. (b) In responding cancer-type only a subset responds. 
Because of (a), if (ii) and (iii) are true, then cancer cell needs to modulate TIME in all tumors. Certain immune cells are dysregulated in tumors.  (a) implies that (ii) and (iii) is unlikely. 

Both (a) and (b) suggests that (i) is most likely plausible explanation. 


In the following analysis, I plan to identify genes associated with ICB response. Then identify if they are markers of certain immune cells. Then in scRNA data, check between responders and non-responders among what immune cells this are differntially expressed. This need to be run in hierarchical manner to zeroin to that specific cell type.

## Evaluate association of genes with ICB resposne and survival with mixed model
```{r}
# Patient Response
icb.response.dt =  do.call(rbind, sapply(names(followups), function(tt) {
    followups[[tt]][,list(Patient, Response, dataset=tt)]
}, simplify = F))

pfs.dt =  do.call(rbind, sapply(names(followups), function(tt) {
    tryCatch(followups[[tt]][,list(Patient,  PFS, PFS.Event, dataset=tt)],
             error = function(e) NULL)
}, simplify = F))

os.dt =  do.call(rbind, sapply(names(followups), function(tt) {
    tryCatch(followups[[tt]][,list(Patient,  OS, OS.Event, dataset=tt)],
             error = function(e) NULL)
}, simplify = F))



```


## create big expression mat with NAN 
```{r}
create.deepImmune.input <- function(output.dir, expression.file,  genes.curr) {
    aa = fread(expression.file)
    genes.inx = match(genes.curr, aa$Symbol)
    exp.mat = as.matrix(t(aa[genes.inx,-1,with=F]) )
    colnames(exp.mat) = genes.curr
    exp.mat
}
expression.mat.list  = sapply(expression.files, function(expression.file) {
    aa = fread(expression.file)
    genes.curr= aa$Symbol
    exp.mat = as.matrix(t(aa[,-1,with=F]) )
    colnames(exp.mat) = genes.curr
    exp.mat = apply(exp.mat,2,avinash::znorm)
    exp.mat
}
)
all.genes  = unique(unlist(sapply(expression.mat.list, colnames)))
dataset.name  = sapply(expression.files, basename)
names(expression.mat.list) = dataset.name
expression.merge = do.call(rbind, sapply(expression.mat.list, function(tt) tt[,match(all.genes, colnames(tt))], simplify = F))
nan.inx = apply(expression.merge,2,function(tt) sum(!is.na(tt)))
expression.merge = expression.merge[,nan.inx > 200]
all.genes.sel = all.genes[nan.inx > 200]
colnames(expression.merge) = all.genes.sel
icb.response.dt = icb.response.dt[!is.na(Response)]
icb.response.dt[,Response1:=as.integer(ifelse(Response> 0, 1,0))]
```



## ICB response 

```{r}
library(parallel)
expression.merge.match = expression.merge[match(icb.response.dt[,paste(Patient, dataset), ],meta.info.dt$label),]

extract_nmle_table <- function (m1){
    mod = summary(m1)
    beta <- m1$coefficients$fixed[2] #$fixed is not needed
    se <- m1$varFix[2]
    t <- beta/se
    p<- anova(m1)[2,4]
    table=data.frame(cbind(beta,se,t,p))
    return(table)
}
library(nlme)
eval.nlme = function(gene.expression, data.dt){
    # data.dt = data.table with colums  Response1 and dataset (factor to control)
    tryCatch(
        {
            data.dt$col = gene.expression
            data.dt = data.dt[!is.na(col)]
            data.dt = data.dt[dataset %in% names(which(table(data.dt$dataset) > 10))]  # only choose those with at least 10 obervations 
            m1 <- lme(col~ Response1, random=~1|dataset, data=data.dt)
            extract_nmle_table(m1)
        },error=  function(e) rep(NA,4))
}
icb.response.genes = mclapply(seq(ncol(expression.merge.match)), function(tt) eval.nlme(expression.merge.match[,tt], data.dt=icb.response.dt), mc.cores=45)
icb.response.genes.dt =  data.table(do.call(rbind, icb.response.genes))[,genes:=all.genes.sel]
setnames(icb.response.genes.dt, 1:4, c("estimate","se", "z", "P"))
library(magrittr)
icb.response.genes.dt = icb.response.genes.dt %>%
    .[!is.na(estimate)] %>%
    .[order(P)]  %>% 
    .[,effect:=sign(estimate)*ifelse(abs(estimate)-se < 0, 0, abs(estimate)-se)]

library(EnhancedVolcano)
p.response = EnhancedVolcano(icb.response.genes.dt,
                             lab = icb.response.genes.dt$genes,
                             x = 'estimate',
                             y = 'P',
                             pCutoff = 5e-5,
                             FCcutoff = .2,
                             ylim = c(0,5.2),
                             xlim = c(-1, 1),
                             # pointSize = 4.0,
                             pointSize = c(ifelse(icb.response.genes.dt$P< 5E-5, 2, 0.5)),
                             labSize = 4.0,
                             legend=c('NS','Log (base 2) fold-change','P value',
                                      'P value & Log (base 2) fold-change'),
                             legendPosition = 'right',
                             legendLabSize = 8,
                             legendIconSize = 4.0,
                             drawConnectors = TRUE,
                             widthConnectors = 0.2,
                             colAlpha = 0.8,
                             colConnectors = 'grey30'
)

ggsave(filename="~/p.response.pdf", width=10, height=10)

```


## PFS survival 

```{r, echo=FALSE}
library(coxme)
expression.merge.match = expression.merge[match(pfs.dt[,paste(Patient, dataset), ],meta.info.dt$label),]
pfs.response.dt = pfs.dt

setnames(pfs.response.dt, 2:3, c("Surival", "Event"))

extract_coxme_table <- function (mod){
    beta <- mod$coefficients #$fixed is not needed
    nvar <- length(beta)
    nfrail <- nrow(mod$var) - nvar
    se <- sqrt(diag(mod$var)[nfrail + 1:nvar])
    z<- round(beta/se, 2)
    p<- signif(1 - pchisq((beta/se)^2, 1), 2)
    table=data.frame(cbind(beta,se,z,p))
    return(table)
}
eval.coxme = function(dat, dtx){
    tryCatch(
        {
            dtx$col = dat
            dtx = dtx[!is.na(col)]
            dtx = dtx[dataset %in% names(which(table(dtx$dataset) > 10))] 
            aa =  coxme(Surv(Surival, Event) ~ col + (1|dataset), dtx)
            extract_coxme_table(aa)
        },error=  function(e) rep(NA,4))
}
pfs.response.genes = mclapply(seq(ncol(expression.merge.match)), function(tt) eval.coxme(expression.merge.match[,tt], dtx=pfs.response.dt), mc.cores=30)
pfs.response.genes.dt =  data.table(do.call(rbind, pfs.response.genes))[,genes:=all.genes.sel]
setnames(pfs.response.genes.dt, 1:4, c("estimate","se", "z", "P"))
library(magrittr)
pfs.response.genes.dt = pfs.response.genes.dt %>%
    .[!is.na(estimate)] %>%
    .[order(P)]  %>% 
    .[,effect:=sign(estimate)*ifelse(abs(estimate)-se < 0, 0, abs(estimate)-se)]

library(EnhancedVolcano)
p.pfs = EnhancedVolcano(pfs.response.genes.dt,
                        lab = pfs.response.genes.dt$genes,
                        x = 'estimate',
                        y = 'P',
                        pCutoff = 1e-5,
                        FCcutoff = .3,
                        # ylim = c(0,5.2),
                        xlim = c(-1, 1),
                        # pointSize = 4.0,
                        # pointSize = c(ifelse(pfs.response.genes.dt$P< 3E-4, 1, 0.5)),
                        labSize = 4.0,
                        legend=c('NS','Log (base 2) fold-change','P value',
                                 'P value & Log (base 2) fold-change'),
                        legendPosition = 'right',
                        legendLabSize = 8,
                        legendIconSize = 4.0,
                        drawConnectors = TRUE,
                        widthConnectors = 0.2,
                        colAlpha = 0.8,
                        colConnectors = 'grey30'
)
ggsave(filename="~/p.pfs.pdf", width=10, height=5)
```



## OS survival 

```{r}
expression.merge.match = expression.merge[match(os.dt[,paste(Patient, dataset), ],meta.info.dt$label),]
os.response.dt = os.dt

setnames(os.response.dt, 2:3, c("Surival", "Event"))

os.response.genes = mclapply(seq(ncol(expression.merge.match)), function(tt) eval.coxme(expression.merge.match[,tt], dtx=os.response.dt), mc.cores=30)
os.response.genes.dt =  data.table(do.call(rbind, os.response.genes))[,genes:=all.genes.sel]
setnames(os.response.genes.dt, 1:4, c("estimate","se", "z", "P"))
library(magrittr)
os.response.genes.dt = os.response.genes.dt %>%
    .[!is.infinite(z)] %>%
    .[!is.na(estimate)] %>%
    .[order(P)]  %>% 
    .[,effect:=sign(estimate)*ifelse(abs(estimate)-se < 0, 0, abs(estimate)-se)]

library(EnhancedVolcano)
p.os = EnhancedVolcano(os.response.genes.dt,
                       lab = os.response.genes.dt$genes,
                       x = 'estimate',
                       y = 'P',
                       pCutoff = 1e-4,
                       FCcutoff = .3,
                       # ylim = c(0,5.2),
                       xlim = c(-1, 1),
                       # pointSize = 4.0,
                       # pointSize = c(ifelse(os.response.genes.dt$P< 3E-4, 1, 0.5)),
                       labSize = 4.0,
                       legend=c('NS','Log (base 2) fold-change','P value',
                                'P value & Log (base 2) fold-change'),
                       legendPosition = 'right',
                       legendLabSize = 8,
                       legendIconSize = 4.0,
                       drawConnectors = TRUE,
                       widthConnectors = 0.2,
                       colAlpha = 0.8,
                       colConnectors = 'grey30'
)


```
## Plot survival in TCGA 
# 1. control for T-cell infiltration. 
# 2. do not control 
```{r}
library(readxl)
library(magrittr)
bcc = readRDS("~/project/deeplearning/icb/data/sc/GSE123814_human_aPD1/GSE123813_bcc_scRNA_counts.rds")
colnames(bcc) = paste(colnames(bcc), seq(ncol(bcc)), sep="_")
metadata.dca = fread("~/project/deeplearning/icb/data/sc/GSE123814_human_aPD1//GSE123813_bcc_metadata.txt")
bcc.response = data.table(read_excel("/liulab/asahu/data/MAESTRO/41591_2019_522_MOESM2_ESM.xlsx", sheet = 1, skip = 3))
bcc.response = bcc.response[1:15,]
nonresponders = bcc.response[Response == "No"]$Patient 
responders = bcc.response[Response != "No"]$Patient 
metadata.dca[,response:=ifelse(patient %in% responders, 1, ifelse(patient %in% nonresponders, 0, NA))]

# bcc.sco = preprocessing.scRNA(bcc, project.name = "bcc",  meta.data=NULL)
bcc.sco = preprocessing.scRNA(bcc, project.name = "bcc",  meta.data=as.data.frame(metadata.dca) %>%set_rownames(colnames(bcc)))
variablegenes<- Seurat::VariableFeatures(Seurat::FindVariableFeatures(bcc.sco, selection.method = "vst", nfeatures = 2500))
rm(bcc); gc()
```

## 
1. Among differentiall expressed genes, find what cell-types they are differntially expressed between responders and non-responders
2. 

```{r}


celltype.icbgene.plot <- function(icb.genes) {
    exp.sel.mat = bcc[rownames(bcc) %in% icb.genes,]
    metadata.dca$inx = seq(nrow(metadata.dca))
    cell.types = unique(metadata.dca$cluster)
    pre.stat = list()
    for (grp in cell.types) {
        responder.grp = metadata.dca[(patient%in% responders) & (treatment == "pre") & (cluster == grp)]$inx
        nonresponder.grp = metadata.dca[(patient%in% nonresponders) & (treatment == "pre") & (cluster == grp)]$inx
        out1 = apply(exp.sel.mat, 1, function(tt) {
            tryCatch({
                aa = wilcox.test(tt[responder.grp], tt[nonresponder.grp])
                bb = log2(mean(tt[responder.grp])+.01) - log2( mean(tt[nonresponder.grp]) +.01)
                c(P=aa$p.value, logFC=bb)
            }, 
            error = function(e) c(P=NA, logFC=NA))
        })
        out = data.table(t(out1))[,type:=grp][,gene:=colnames(out1)] 
        pre.stat[[grp]] = out
    }
    
    pre.stat.dt = do.call(rbind, pre.stat)
    library(ggrepel)
    library(ggplot2)
    pre.stat.dt = pre.stat.dt[!is.na(P)][!is.nan(P)]
    pre.stat.dt = pre.stat.dt[,logp:=-log10(P)]
    pre.stat.dt[,lfc:=sign(logFC)*ifelse(abs(logFC)> 1,1,abs(logFC))]
    pre.stat.dt[,color:=ifelse(lfc>0,"up", "down")]
    p.sc.volcano = ggplot(data=pre.stat.dt, aes(y=logp, x= lfc))  +
        geom_text(aes(label=gene, color=color), size=2, alpha=0.8) +
        facet_wrap(~type, scales = "free_y") +
        theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
        xlim(c(-1.2, 1.2)) + 
        theme(legend.position = "none")
    p.sc.volcano
}

# icb.genes =  icb.response.genes.dt[estimate>0][1:50]$genes
p = icb.response.genes.dt[estimate<0][1:100]$genes %>%
    celltype.icbgene.plot(.)
ggsave("~/p.100.neg.sc.volcano.pdf", p, width=10, height=7)


post.stat = list()
for (grp in cell.types) {
    responder.grp = metadata.dca[(patient%in% responders) & (treatment == "post") & (cluster == grp)]$inx
    nonresponder.grp = metadata.dca[(patient%in% nonresponders) & (treatment == "post") & (cluster == grp)]$inx
    out1 = apply(exp.sel.mat, 1, function(tt) {
        tryCatch({
            aa = wilcox.test(tt[responder.grp], tt[nonresponder.grp])
            bb = log2(mean(tt[responder.grp])+.01) - log2( mean(tt[nonresponder.grp]) +.01)
            c(P=aa$p.value, logFC=bb)
        }, 
        error = function(e) c(P=NA, logFC=NA))
    })
    out = data.table(t(out1))[,type:=grp][,gene:=colnames(out1)] 
    post.stat[[grp]] = out
}

post.stat.dt = do.call(rbind, post.stat)
library(ggrepel)
library(ggplot2)
post.stat.dt = post.stat.dt[!is.na(P)][!is.nan(P)]
post.stat.dt = post.stat.dt[,logp:=-log10(P)]
post.stat.dt[,lfc:=sign(logFC)*ifelse(abs(logFC)> 1,1,abs(logFC))]
post.stat.dt[,color:=ifelse(lfc>0,"up", "down")]
p.post.sc.volcano = ggplot(data=post.stat.dt, aes(y=logp, x= lfc))  +
    geom_text(aes(label=gene, color=color), size=2, alpha=0.8) +
    facet_wrap(~type, scales = "free_y") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
    xlim(c(-1.2, 1.2)) + 
    theme(legend.position = "none")

ggsave("~/p.post.sc.volcano.pdf", p.post.sc.volcano, width=10, height=7)
## post therapy 
```



## Controlling for cell-type, perform differntial expresion analysis betweene responders and non-responders 
```{r}

# as.formula("y ~ x1 + x2")
## 4000 differentially expressed icb.genes + 2500 most variable genes. 
require(parallel)
differential.expression <- function(expression.mat) {
    cell.types = unique(meta.data.curr$cluster)
    icb.genes = rownames(expression.mat)
    pre.stat = list()
    for (grp in cell.types) {
        responder.grp = meta.data.curr[(response==1) & (treatment == "pre") & (cluster == grp)]$inx
        nonresponder.grp = meta.data.curr[(response==0) & (treatment == "pre") & (cluster == grp)]$inx
        out1 = mclapply(seq(nrow(expression.mat)), function(uu) {
            tt = expression.mat[uu,]
            tryCatch({
                aa = wilcox.test(tt[responder.grp], tt[nonresponder.grp])
                bb = log2(mean(tt[responder.grp])+.01) - log2( mean(tt[nonresponder.grp]) +.01)
                c(P=aa$p.value, logFC=bb)
            }, 
            error = function(e) c(P=NA, logFC=NA))
        }, mc.cores = 32)
        out1  = do.call(rbind, out1)
        out = data.table(out1)[,type:=grp][,gene:=icb.genes] 
        pre.stat[[grp]] = out
    }
    
    pre.stat.dt = data.table(do.call(rbind, pre.stat))
    # pre.stat.dt = pre.stat.dt[!is.na(P)][!is.nan(P)]
    # pre.stat.dt = pre.stat.dt[,logp:=-log10(P)]
    pre.stat.dt
}

genes.sel = unique(c(icb.response.genes.dt[estimate>0][1:1000]$genes, icb.response.genes.dt[estimate<0][1:1000]$genes, variablegenes))
genes.sel = intersect(genes.sel, rownames(bcc.sco))

bcc.sco.subset = bcc.sco[genes.sel,]
expression.curr = bcc.sco.subset[["RNA"]]@data
meta.data.curr = data.table(bcc.sco.subset@meta.data)
meta.data.curr$inx = seq(nrow(meta.data.curr))
diff.exp.dt = differential.expression(expression.curr)

diff.exp.dt$bulk.icb.deg=icb.response.genes.dt[match(diff.exp.dt$gene, genes)]$estimate

avi.dt = diff.exp.dt[!is.na(P)][,logP:=-log10(P+1E-35)]
avi.dt = avi.dt[order(P)]
avi.dt$label = ""
for (var in unique(avi.dt$type)) {
     avi.dt[type==var][1:20]$label = avi.dt[type==var][1:20]$gene
    
}
# avi.top.dt = do.call(rbind, lapply(unique(avi.dt$type), function(tt) avi.dt[type==tt][1:10] ))
library(ggrepel)
p.scrna.volcano = ggplot(data=avi.dt, aes(y=logP, x= logFC))  +
    geom_point(alpha=0.4,size=0.5) + 
      geom_text_repel(aes(label=label), size=2, alpha=0.8) +
    facet_wrap(~type, scales = "free") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
    # xlim(c(-1.2, 1.2)) + 
    theme(legend.position = "none")

ggsave("~/p.scrna.volcano.pdf", p.scrna.volcano, width=10, height=7)


p.bulk.scrna = ggplot(data=avi.dt, aes(y=bulk.icb.deg, x= logFC))  +
    geom_point(alpha=0.5,size=0.5) + 
      geom_text(aes(label=label), size=2, alpha=0.8) +
    facet_wrap(~type, scales = "free") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
    # xlim(c(-1.2, 1.2)) + 
    theme(legend.position = "none")

ggsave("~/p.bulk.scrna.pdf", p.bulk.scrna, width=10, height=7)


for (cell.type.sel in unique(meta.data.curr$cluster)) {
    metadata.dca.sel = meta.data.curr %>%
        .[,inx:=seq(nrow(meta.data.curr))] %>% 
        .[treatment=="pre"] %>%
        .[cluster %in% cell.type.sel]%>%
        .[!is.na(response)] 
    
}
        

library(lme4)
eval.glmer1 = function(dat, dtx, Formula, family= "binomial"){
    if( !class(Formula)=="formula") Formula = as.formula(Formula)
    tryCatch(
        {
            dtx$col = dat
            dtx = dtx[!is.na(col)]
            aa = glmer(data= dtx, formula=Formula, family = family)
            summary(aa)$coefficient[2,]
        },error=  function(e) rep(NA,4))
}

metadata.dca.curr = metadata.dca[(treatment=="pre") & (patient %in% c(responders, nonresponders))]
bcc.pretreatment = bcc[,metadata.dca.curr$inx]
lmm.dt =  metadata.dca.curr %>% 
    .[,response:=ifelse(patient %in% responders,1,0)] %>%
    .[,.(response, cluster)]
deg.resp.lmm = mclapply(seq(nrow(bcc.pretreatment)), function(tt){
    eval.glmer1(dat=bcc.pretreatment[tt,], dtx=lmm.dt, Formula="response ~ col + (1|cluster)")
}, mc.cores=28)


lmm.dt =  metadata.dca.curr %>% 
    .[,response:=ifelse(patient %in% responders,1,0)] %>%
    .[,.(response, cluster)]
deg.resp.lmm = mclapply(seq(nrow(bcc.pretreatment)), function(tt){
    eval.glmer1(dat=log2(bcc.pretreatment[tt,], dtx=lmm.dt, Formula="col ~ response  + (1|cluster)")
}, mc.cores=28)
    
    scrna.response.genes.dt =  data.table(do.call(rbind, deg.resp.lmm))[,genes:=rownames(bcc.pretreatment)]
    setnames(scrna.response.genes.dt, 1:4, c("estimate","se", "z", "P"))
    scrna.response.genes.dt = scrna.response.genes.dt %>%
        .[!is.infinite(z)] %>%
        .[!is.na(estimate)] %>%
        .[order(abs(z), decreasing = T)]  %>% 
        .[,effect:=sign(estimate)*ifelse(abs(estimate)-abs(se) < 0, 0, abs(estimate)-abs(se))]
    
    library(EnhancedVolcano)
    p.scrna = EnhancedVolcano(scrna.response.genes.dt,
                              lab = scrna.response.genes.dt$genes,
                              x = 'estimate',
                              y = 'P',
                              pCutoff = 1e-4,
                              FCcutoff = .3,
                              # ylim = c(0,5.2),
                              # xlim = c(-1, 1),
                              # pointSize = 4.0,
                              # pointSize = c(ifelse(scrna.response.genes.dt$P< 3E-4, 1, 0.5)),
                              labSize = 4.0,
                              legend=c('NS','Log (base 2) fold-change','P value',
                                       'P value & Log (base 2) fold-change'),
                              legendPscrnaition = 'right',
                              legendLabSize = 8,
                              legendIconSize = 4.0,
                              drawConnectors = TRUE,
                              widthConnectors = 0.2,
                              colAlpha = 0.8,
                              colConnectors = 'grey30'
    )
    
    ```
    
    
    ## Test transfer learning from scRNA to bulk
    1. find differentially expressed, and cell types
    2. Write datasets
    ```{r}
    library(avinash)
    icb.genes = icb.response.genes.dt[1:100]$genes
    # icb.genes.common 
    icb.genes.common = intersect(icb.genes, rownames(bcc.sco))
    # CD8_ex_T_cells, CD8_mem_T_cells, Tcell_prolif, Tregs, Tumor_1
    
    dir.create("~/project/deeplearning/icb/data/icb/scrna_transer/")
    output.dir = "~/project/deeplearning/icb/data/icb/scrna_transer/howard"
    
    
    cell.type.sel = c("CD8_ex_T_cells", "CD8_mem_T_cells", "Tcell_prolif", "Tregs", "Plasma_cells")  ## not adding the cancer cells 
    cell.type.sel = "CD8_ex_T_cells"
    
    
    
    metadata.dca.sel = data.table(bcc.sco@meta.data) %>%
        .[,inx:=seq(ncol(bcc.sco))] %>% 
        .[treatment=="pre"] %>%
        .[cluster %in% cell.type.sel]%>%
        .[!is.na(response)] 
    bcc.exp.sel = t(apply(bcc.sco[["RNA"]]@data[icb.genes.common, metadata.dca.sel$inx], 1, avinash::qnorm.array))
    bcc.exp.sel[is.na(bcc.exp.sel)] = 0
    scrna.datset = data.table(cbind(cancertype=metadata.dca.sel$cluster, t(bcc.exp.sel), response=as.numeric(metadata.dca.sel$response)))
    
    write.dataset(output.dir = "~/project/deeplearning/icb/data/icb/scrna_transer/howard", dataset = scrna.datset, sample.name = colnames(bcc.exp.sel))
    # write.dataset(output.dir = output.dir, dataset = all.icb.dataset, sample.name = rownames(all.expression))
    # file.copy("~/project/deeplearning/icb/data/icb/tf/params.json", output.dir)
    # file.copy("~/project/deeplearning/icb/data/icb/tf/datasets_tsne_list.txt", output.dir)
    # file.copy("~/project/deeplearning/icb/data/icb/tf/datasets_test_list.txt", output.dir)
    icb.response.dt$label = icb.response.dt[,paste(Patient, dataset)]
    
    for (dataset.curr in unique(icb.response.dt$dataset)) {
        icb.response.dt.curr = icb.response.dt[dataset==dataset.curr][label %in% meta.info.dt$label]
        expression.icb.sel = apply(expression.merge[match(icb.response.dt.curr$label, meta.info.dt$label),  icb.genes.common], 2, avinash::qnorm.array)
        expression.icb.sel[is.na(expression.icb.sel)] = 0
        
        icb.dataset.curr = data.table(cbind(cancertype=dataset.curr, expression.icb.sel, response=icb.response.dt.curr$Response1))
        dataset.dir = sprintf("~/project/deeplearning/icb/data/icb/scrna_transer/%s", dataset.curr)
        write.dataset(output.dir = dataset.dir, dataset = icb.dataset.curr, sample.name = icb.response.dt.curr[,paste(Patient, dataset)])
        out = sprintf("\"%s\"	\"icb\"	\"[1,1,1]\"	\"../data/icb/scrna_transer/%s\"	1	['all']	[0,0]", dataset.curr, dataset.curr)
        message(out)
    }
    # hist(bcc.exp.sel[1,],100)
    # hist(expression.icb.sel[,1],100)
    
    
    ```
    
    ## train scRNA and test bulk
    ```{r}
    CUDA_VISIBLE_DEVICES=2 python train.py  --data_dir  ~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/.
    
    CUDA_VISIBLE_DEVICES=1 python evaluate.py  --data_dir  ~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_test_list.txt --model_dir --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/.   --restore_file --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/. /epoch-22.pth.tar 
    ```
    
    ## Run for each cell types 
```{r}
temp1 = data.table(bcc.sco@meta.data)
temp2 = as.matrix(bcc.sco[["RNA"]]@data)
save(file="~/temp.RData", temp1, temp2,icb.genes.common)
library(Seurat)
for (cell.type.sel in unique(temp1$cluster)) {
  
  metadata.dca.sel = temp1 %>%
    .[,inx:=seq(nrow(temp1))] %>% 
    .[treatment=="pre"] %>%
    .[cluster %in% cell.type.sel]%>%
    .[!is.na(response)] 
  bcc.exp.sel = t(apply(temp2[icb.genes.common, metadata.dca.sel$inx], 1, avinash::qnorm.array))
  bcc.exp.sel[is.na(bcc.exp.sel)] = 0
  scrna.datset = data.table(cbind(cancertype=metadata.dca.sel$cluster, t(bcc.exp.sel), response=as.numeric(metadata.dca.sel$response)))
  
  avinash::write.dataset(output.dir = "~/project/deeplearning/icb/data/icb/scrna_transer/howard", dataset = scrna.datset, sample.name = colnames(bcc.exp.sel))
  
  command = sprintf("CUDA_VISIBLE_DEVICES=2 python train.py  --data_dir  ~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/.  --tensorboard_prefix %s_", cell.type.sel)
  system(command = command, wait = T,ignore.stdout = F)
}

## read the output files 

library(Seurat)
predictor_celltype_dir= list.files(path="~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/", pattern = "^avi", full.names=T)

out = list() 
for (ct.dir in predictor_celltype_dir) {
  temp = basename(ct.dir)
  cell.type = substring(temp, 5, nchar(temp) - 16)
  aa = sapply(list.files(path=ct.dir, pattern="^best_val", full.names = T), function(tt) {
    aa = fread(tt)
    tryCatch(
      pROC::auc(aa$response, aa$response.output, quiet=T, direction = "<"),
      error = function(e) NA)
  }, USE.NAMES =T)
  out[[cell.type]] = aa %>%
  set_names(basename(names((aa)))) 
}

out.mat = do.call(rbind, out)
dataset.order = fread("~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/vargene_Tumor_2_20200317-013307/datasets_tsne_list.txt") %>%
.[,inx:=seq(.N)-1] %>%
.[,filename:=paste0("best_val_",inx,".csv")]%>%
.[match(colnames(out.mat),filename)]
colnames(out.mat) = c("Howard", dataset.order$prefix[-1])
predictor.icb.from.howard = out.mat

predictor.dt = data.table(melt(out.mat))
predictor.dt = predictor.dt[!is.na(value)]
p.predictor = ggplot(data=predictor.dt, aes(y = value, x = as.factor(Var1)))  +
  geom_bar(aes(fill = as.factor(Var2)), stat="identity", position = position_dodge(preserve = 'single')) + 
  coord_flip() + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
  theme(legend.position = "none")
# print(p.predictor)
ggsave(".figs/icb.from.howard.pdf", p.predictor)

```
    
## Evaluate the difference of ICB cohort and other cohort. 
1. 
```{r}
  
        

out = list() 
for (ct.dir in predictor_celltype_dir) {
  temp = basename(ct.dir)
  cell.type = substring(temp, 5, nchar(temp) - 16)
  out[[cell.type]] = do.call(rbind, lapply(list.files(path=ct.dir, pattern="^best_val", full.names = T), function(tt) 
    {
    aa = fread(tt)
    aa[,dataset:=basename(tt)]
    }))
}




require(uwot)
require(ggthemes)
require(ggplot2)
umap.mat = as.matrix(out[[2]][,grep("^embedding", colnames(out[[1]])), with=F])
umap.model <- umap(umap.mat, pca = NULL, ret_model = T)
d_umap = cbind(out[[2]], data.table(umap.model$embedding))
create.text = function(tt) gsub(".csv", gsub("best_val_", tt, replacement=""),replacement="")
d_umap$text=create.text(d_umap$dataset)
p = ggplot(d_umap, aes(x = V1, y = V2)) + 
  geom_point(aes(color = dataset), alpha = 0.8) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic() 
print(p)
p = ggplot(d_umap[V1 > -10], aes(x = V1, y = V2)) + 
  geom_text(aes(label = text), alpha = 0.8, size=2) +
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic() 
print(p)

```


## Use variable genes      
## Read ICB read count data. 
```{r}
clinical.files = list.files(path = "~/liulab_home/data/immunotherapy-trials/ICB_for_Jingxin/", pattern = ".clinical", full.names = T, recursive = T)
clinical.data = lapply(clinical.files, fread)
names(clinical.data) = sapply(clinical.files, basename)

count.files = list.files(path = "~/liulab_home/data/immunotherapy-trials/immunotherapy-trials/htseq/", pattern = ".htseq", full.names = T)

icb.counts.list = lapply(count.files, fread) 
names(icb.counts.list) = gsub(".htseq", sapply(count.files, basename), replacement = "")
dataset.map = data.table(name=names(icb.counts.list)) %>% 
  .[,lastauthor:=sapply(name, 
                                function(tt){
                                  aa=unlist(strsplit(tt, split="_"))
                                  aa[length(aa)]
                                  })]

emsembl2hgnc.dt = avinash::ensembl2hgnc()
genes.dt = data.table(icb.counts.list[[1]]$ENSEMBL_GeneID) %>%
  .[,V2:=sapply(V1, function(tt) strsplit(tt, split="\\.")[[1]][1])] %>% 
  .[,inx:=seq(.N)] %>% 
  .[,gene:=emsembl2hgnc.dt$hgnc_symbol[match(V2, emsembl2hgnc.dt$ensembl_gene_id)]] %>%
    .[!is.na(gene)] %>% 
  .[which(gene %in%  genentech.env$bb$Symbol)] %>% 
  .[which(gene %in% rownames(bcc))] 
genentech.env = local({load("/liulab/asahu/data/ssgsea/xiaoman/genentech.phenotype.RData");environment()})
genes.sel = intersect(intersect(genentech.env$bb$Symbol, genes.dt$gene)

dataset.map[,inx:=sapply(lastauthor, function(tt) grep(tt, dataset.name))]
dataset.sel = unlist(dataset.map$inx)
# dataset.sel.list = sapply(dataset.sel, function(tt){
#   followup = followups[[tt]]
#   inx.sel = which(sapply(dataset.map$inx, function(uu)  tt %in% uu))
#   exp.curr = icb.counts.list[[inx.sel]][genes.dt$inx, ]
#   patient.sel = intersect(colnames(exp.curr), followup$Patient)
#   patient.sel.inx = which(colnames(exp.curr) %in% patient.sel)
#   list(name=names(followups)[[tt]], expression=exp.curr[,pateint.sel.inx,with=F], followup = followup[Patient%in% patient.sel])
# })

obj.sel = c("BMS064", "Mel_PD1_Riaz")
icb.obj.list = list()
for (obj in obj.sel) {
  raw.read1 =icb.counts.list[[obj]]
  raw.read = as.matrix(raw.read1[genes.dt$inx, -1,with=F])
  rownames(raw.read) = genes.dt$gene
  icb.obj.list[[obj]] = CreateSeuratObject(counts=raw.read)
}

raw.read = genentech.env$cc[match(genes.dt$gene, genentech.env$bb$Symbol),]
rownames(raw.read) = genes.dt$gene
icb.obj.list$Mariathasan2018 = CreateSeuratObject(count=raw.read)

library(Seurat)
for (i in 1:length(icb.obj.list)) {
    icb.obj.list[[i]] <- NormalizeData(icb.obj.list[[i]], verbose = FALSE)
    icb.obj.list[[i]] <- FindVariableFeatures(icb.obj.list[[i]], selection.method = "vst", 
        nfeatures = 2000, verbose = FALSE)
}

intersected.genes = intersect(colnames(expression.merge), variablegenes)
variable.genes.list = lapply(icb.obj.list, VariableFeatures)
variable.genes.union = unique(unlist(variable.genes.list))
variable.gene.mat = sapply( variable.genes.list, function(tt) (variable.genes.union %in% intersect(tt, intersected.genes) + 0 ))

variable.genes.sel = variable.genes.union[rowSums(variable.gene.mat) > 1]
```




## Write dataset and run deepImmune

```{r}
library(avinash)
genes.curr = variable.genes.sel
icb.response.dt$label = icb.response.dt[,paste(Patient, dataset)]

for (dataset.curr in unique(icb.response.dt$dataset)) {
  icb.response.dt.curr = icb.response.dt[dataset==dataset.curr][label %in% meta.info.dt$label]
  
  expression.icb.sel = apply(expression.merge[match(icb.response.dt.curr$label, meta.info.dt$label),  genes.curr], 2, avinash::qnorm.array)
  expression.icb.sel[is.na(expression.icb.sel)] = 0
  
  icb.dataset.curr = data.table(cbind(cancertype=dataset.curr, expression.icb.sel, response=icb.response.dt.curr$Response1))
  dataset.dir = sprintf("~/project/deeplearning/icb/data/icb/scrna_transer/%s", dataset.curr)
  write.dataset(output.dir = dataset.dir, dataset = icb.dataset.curr, sample.name = icb.response.dt.curr[,paste(Patient, dataset)])
  out = sprintf("\"%s\"	\"icb\"	\"[1,1,1]\"	\"../data/icb/scrna_transer/%s\"	1	['all']	[0,0]", dataset.curr, dataset.curr)
  message(out)
}

```


```{r}

temp1 = data.table(bcc.sco@meta.data)
temp2 = as.matrix(bcc.sco[["RNA"]]@data)
save(file="~/temp.RData", temp1, temp2,variable.genes.sel)
library(Seurat)

for (cell.type.sel in unique(temp1$cluster)) {
  
  metadata.dca.sel = temp1 %>%
    .[,inx:=seq(nrow(temp1))] %>% 
    .[treatment=="pre"] %>%
    .[cluster %in% cell.type.sel]%>%
    .[!is.na(response)] 
  bcc.exp.sel = t(apply(temp2[variable.genes.sel, metadata.dca.sel$inx], 1, avinash::qnorm.array))
  bcc.exp.sel[is.na(bcc.exp.sel)] = 0
  scrna.datset = data.table(cbind(cancertype=metadata.dca.sel$cluster, t(bcc.exp.sel), response=as.numeric(metadata.dca.sel$response)))
  
  avinash::write.dataset(output.dir = "~/project/deeplearning/icb/data/icb/scrna_transer/howard", dataset = scrna.datset, sample.name = colnames(bcc.exp.sel))
  
  command = sprintf("CUDA_VISIBLE_DEVICES=2 python train.py  --data_dir  ~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_tsne_list.txt --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/.  --tensorboard_prefix vargene_%s_", cell.type.sel)
  system(command = command, wait = T,ignore.stdout = F)
}

## read the output files 

out = list() 
predictor_celltype_dir= list.files(path="~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/", pattern = "^vargene_", full.names=T)
for (ct.dir in predictor_celltype_dir) {
  temp = basename(ct.dir)
  cell.type = substring(temp, 5, nchar(temp) - 16)
  aa = sapply(list.files(path=ct.dir, pattern="^best_val", full.names = T), function(tt) {
    aa = fread(tt)
    tryCatch(
      pROC::auc(aa$response, aa$response.output, quiet=T, direction = "<"),
      error = function(e) NA)
  }, USE.NAMES =T)
  out[[cell.type]] = aa %>%
  set_names(basename(names((aa)))) 
}

out.mat = do.call(rbind, out)
dataset.order = fread("~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/vargene_Tumor_2_20200317-013307/datasets_tsne_list.txt") %>%
.[,inx:=seq(.N)-1] %>%
.[,filename:=paste0("best_val_",inx,".csv")]%>%
.[match(colnames(out.mat),filename)]
colnames(out.mat) = c("Howard", dataset.order$prefix[-1])
predictor.icb.from.howard = out.mat

predictor.dt = data.table(melt(out.mat))
predictor.dt = predictor.dt[!is.na(value)][Var2!="Liu2019_PD1_Melanoma_RNASeq_Ipi.Prog"]
p.predictor = ggplot(data=predictor.dt, aes(y = value, x = as.factor(Var2)))  +
  geom_bar(aes(fill = as.factor(Var1)), stat="identity", position = position_dodge(preserve = 'single')) + 
  geom_hline(yintercept = 0.5) +
  coord_flip() + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
  theme(legend.position = "none")
ggsave(filename=".figs/icb.from.howard.vargene.heatmap.pdf", p.predictor)
##
out1 =  out.mat[,!(colnames(out.mat) =="Liu2019_PD1_Melanoma_RNASeq_Ipi.Prog")]
# out1 = out1[, apply(out,2,max) > 0.81]
out1 = out1[order(apply(out1, 1, median)),order(apply(out1, 2, median))]


# Returns a vector of 'num.colors.in.palette'+1 colors. The first 'cutoff.fraction'
# fraction of the palette interpolates between colors[1] and colors[2], the remainder
# between colors[3] and colors[4]. 'num.colors.in.palette' must be sufficiently large
# to get smooth color gradients.
makeColorRampPalette <- function(colors, cutoff.fraction, num.colors.in.palette)
{
  stopifnot(length(colors) == 4)
  ramp1 <- colorRampPalette(colors[1:2])(num.colors.in.palette * cutoff.fraction)
  ramp2 <- colorRampPalette(colors[3:4])(num.colors.in.palette * (1 - cutoff.fraction))
  return(c(ramp1, ramp2))
}

cutoff.distance <- 3  
cols <- makeColorRampPalette(c("white", "red",    # distances 0 to 3 colored from white to red
                               "green", "black"), # distances 3 to max(distmat) colored from green to black
                             cutoff.distance / max(distmat),
                             100)

library(pheatmap)
col1 = colorRampPalette(c("darkgreen", "white", "white","darkred"))(300)
col = col1[c(1:100, seq(101,200,2), 201:300)]
p = pheatmap(t(out1), cluster_rows=F, cluster_cols=F, fontsize_col = 10, color = col, filename=".figs/icb.from.howard.vargene.heatmap.pdf", width = 13, height = 7)
# print(p)

```
## pathway enrichment of differentially expressed genes in single cell data. 

```{r}
# unloadNamespace(c("clusterProfiler", "enrichplot", "DOSE", "GOSemSim", "GO.db"))
# unloadNamespace(c("DOSE"))
# unloadNamespace(c("enrichplot"))
# unloadNamespace(c( "GOSemSim", "enrichplot", "DOSE"))
# unloadNamespace(c( "GOSemSim", "GO.db"))
# unloadNamespace(c("biomaRt"))
# unloadNamespace(c("DO.db"))
# 
# unloadNamespace(c("GO.db", "biomaRt", "DO.db"))
# unloadNamespace(c("GO.db", "biomaRt", "DO.db"))
# unloadNamespace("AnnotationDbi")
# detach('package:AnnotationDbi',unload = T)
# libPaths(aa[c(2,1,3:5)])
# library(clusterProfiler)

gene.eg.dt = clusterProfiler::bitr(unique(diff.exp.dt$gene), fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
universe = clusterProfiler::bitr(rownames(bcc.sco.subset), fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")


diff.exp.dt$ENTREZID = gene.eg.dt[match(diff.exp.dt$gene,gene.eg.dt$SYMBOL),]$ENTREZID

if(FALSE){
  kk <- clusterProfiler::enrichKEGG(gene         = diff.exp.dt[type=="CD8_mem_T_cells"]$ENTREZID,
                                    organism     = 'hsa',
                                    pvalueCutoff = 0.05)
  clusterProfiler::dotplot(kk, showCategory=30) 
}

# For all genes 

diff.exp.dt[, up_or_down:=ifelse(logFC > 0 , "upregulated", "downregulated")]
formula_res_scrna <- clusterProfiler::compareCluster(ENTREZID~up_or_down+type, data=diff.exp.dt[P< 1E-3][!is.na(up_or_down)], fun="clusterProfiler::enrichKEGG", organism="hsa", pvalueCutoff=0.05, universe=universe$ENTREZID)

# ck <- clusterProfiler::compareCluster(geneCluster = gcSample, fun = "enrichKEGG")
# head(as.data.frame(ck))
p = clusterProfiler::dotplot(formula_res_scrna, x=~type) + ggplot2::facet_grid(~up_or_down) + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
ggplot2::ggsave(filename = "~/p.scrna.pathway.resp.noresp.pdf",p, width = 10, height = 10)


```
## pathway enrichment of differentially expressed genes in bulk rnaseq data. 

```{r,echo=F}
require(parallel)

library(matrixTests)
expression.merge.match = expression.merge[match(icb.response.dt[,paste(Patient, dataset), ],meta.info.dt$label),]


differential.expression.bulk <- function(expression.mat, icb.response.dt) {
  
    dataset.inx = unique(icb.response.dt$dataset)
    icb.genes = rownames(expression.mat)
    all.stat = list()
    for (grp in dataset.inx) {
       icb.response.curr = icb.response.dt[(dataset == grp)]
        exp.curr = expression.mat[,icb.response.curr$inx]
        responder.grp = which(icb.response.curr$response==1) 
        nonresponder.grp = which(icb.response.curr$response==0) 
        x = exp.curr[,responder.grp]
        y = exp.curr[, nonresponder.grp]
        aa = matrixTests::row_wilcoxon_twosample(x,y)
        all.stat[[grp]] = data.table(P=aa$pvalue, responder.mean = rowMeans(x,na.rm = T), nonresponder.mean = rowMeans(y,na.rm = T)) %>%
          .[,Padj:=p.adjust(P)] %>%
          .[,type:=grp] %>%
        .[,gene:=icb.genes] 
        
    }
    
    all.stat.dt = data.table(do.call(rbind, all.stat))
    all.stat.dt
}

icb.response.dt[,inx:=seq(.N)][,response:=Response1]
bulk.icb.dt = differential.expression.bulk(t(expression.merge.match), icb.response.dt)
bulk.icb.dt = bulk.icb.dt[!is.na(P)]
bulk.combined.dt = rbind(
  bulk.icb.dt %>%
  .[,up_or_down:=ifelse(responder.mean > nonresponder.mean, "upregulated", "downregulated")] %>%
  .[,.(P, up_or_down, Padj, type, gene=gene)],
  icb.response.genes.dt %>%
    .[,type:="combined"] %>%
  .[,up_or_down:=ifelse(estimate > 0, "upregulated", "downregulated")] %>%
    .[,Padj:=p.adjust(P)] %>%
  .[,.(P, up_or_down, Padj, type, gene=genes)])



gene.eg.dt = clusterProfiler::bitr(unique(bulk.combined.dt$gene), fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

bulk.combined.dt$ENTREZID = gene.eg.dt[match(bulk.combined.dt$gene,gene.eg.dt$SYMBOL),]$ENTREZID
bulk.combined.dt = bulk.combined.dt[!is.na(ENTREZID)]
formula_res <- clusterProfiler::compareCluster(ENTREZID~up_or_down+type, data=bulk.combined.dt[P< 1E-2][!is.na(up_or_down)], fun="clusterProfiler::enrichKEGG", organism="hsa", pvalueCutoff=0.05, universe=gene.eg.dt$ENTREZID)


formula_res_bulk <- compareCluster.unverselist(ENTREZID~up_or_down+type, data=bulk.combined.dt[P< 5E-2][!is.na(up_or_down)], fun="clusterProfiler::enrichKEGG", organism="hsa", pvalueCutoff=0.1, universe.dt=bulk.combined.dt, universe.var = "ENTREZID")

p1 = clusterProfiler::dotplot(formula_res_bulk, x=~type) + ggplot2::facet_grid(~up_or_down) + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(size=6,angle = 90))+
  ggplot2::theme(axis.text.y = ggplot2::element_text(size=10))
# print(p1)
ggplot2::ggsave(filename = "~/p.bulk.pathway.resp.noresp.pdf",p1, width = 15, height = 10)
```

## combining the scRNA and bulk 
```{r}
formula_res_combined = formula_res_bulk
formula_res_combined@compareClusterResult = rbind(formula_res_bulk@compareClusterResult, formula_res_scrna@compareClusterResult)
formula_res_combined@geneClusters = c(formula_res_bulk@geneClusters, formula_res_scrna@geneClusters)
p1 = clusterProfiler::dotplot(formula_res_combined, x=~type) + ggplot2::facet_grid(~up_or_down) + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(size=6,angle = 90))+
  ggplot2::theme(axis.text.y = ggplot2::element_text(size=10))
# print(p1)
ggplot2::ggsave(filename = "~/p.combined.pathway.resp.noresp.pdf",p1, width = 15, height = 10)
```


## cytokines enrichment 

```{r}
cytokines = fread("/liulab/xmwang/oxphos_proj/loading_data/surface/cytokine.txt", header=F)
surface.genes = fread("/liulab/xmwang/oxphos_proj/loading_data/surface/ExpressionLigRec.txt", header=T)
cytokines = intersect(cytokines$V2, all.genes)
cytokine.deg.scrna = diff.exp.dt[which(gene %in% cytokines)] %>%
  .[,estimate:=ifelse(P<0.005, logFC,NA)] %>%
  .[,estimate:=sign(logFC)*sapply(logFC, function(tt) min(2,abs(tt)))] 
# aa = cytokine.deg.scrna[gene%in% "TNFRSF18"][order(P)]
# bb= cytokine.deg.scrna[type %in% "Endothelial"]
# length(unique(cytokine.deg.scrna$gene))
out = dcast(cytokine.deg.scrna, gene~type, value.var="estimate" ) 
out1.scrna = out[,-1,with=F]%>%
  as.matrix(.,rownames=out$gene) %>%
  .[rowMeans(is.na(.)) <1,colMeans(is.na(.)) <1]
  
library(pheatmap)
p.scrna = pheatmap(out1.scrna, cluster_cols = T,fontsize_col = 5, fontsize_row = 5, filename="~/cytokine.deg.scrna.pdf", width = 15, height = 10)

```
## Cytokines in the bulk tumors. 
```{r}
cytokine.deg.bulk = bulk.combined.dt[which(gene %in% rownames(out1))] %>%
  .[,estimate:=ifelse(P<0.05, ifelse(up_or_down=="upregulated",1,-1), 0)]
out = dcast(cytokine.deg.bulk, gene~type, value.var="estimate" ) 
out1.bulk = out[,-1,with=F]%>%
  as.matrix(.,rownames=out$gene) %>%
  .[p.scrna$tree_row$order,colMeans(is.na(.)) <1]

library(pheatmap)
pheatmap(out1.bulk, cluster_cols = T, cluster_row=F, fontsize_col = 5, fontsize_row = 5, filename="~/cytokine.deg.bulk.pdf", width = 15, height = 10)
```
## Combine Nir (Moshe et. al.) data to the analysis

```{r}
# gorgan = readRDS("~/liulab_home/data/single_cell/GSE139555/GSE139555_all_integrated.rds")
# getz = readRDS("/liulab/asahu/data/ssgsea/xiaoman/getz/SKCM_ICB_SeuratObj.rds")
# library(magrittr)
getz = readRDS("/liulab/asahu/data/single_cell/GSE120575/GSE120575_human_aPD1aCTLA4_res.rds")$RNA
getz.resp =  fread("/liulab/asahu/data/ssgsea/xiaoman/getz/GSE120575_patient_ID_single_cells.txt", skip=20, header=F) %>%
.[,1:7,with=F] %>%
.[,V2:=gsub(V2, pattern="-", replacement=".")] %>%
.[,response.bin:=ifelse(V6=="Responder", 1, 0)] %>%
.[,treatment:=ifelse(substring(V5,1,2) == "Pr", "pre", "post")]

differential.expression.new <- function(expression.mat, meta.data) {
    cell.types = unique(meta.data$cluster)
    icb.genes = rownames(expression.mat)
    all.stat =list()
    for (grp in cell.types) {
        responder.grp = meta.data[(response==1) & (treatment == "pre") & (cluster == grp)]$inx
        nonresponder.grp = meta.data[(response==0) & (treatment == "pre") & (cluster == grp)]$inx

        x = expression.mat[,responder.grp]
        y = expression.mat[, nonresponder.grp]
        aa = matrixTests::row_wilcoxon_twosample(x,y)
        all.stat[[grp]] = data.table(P=aa$pvalue, responder.mean = rowMeans(x,na.rm = T), nonresponder.mean = rowMeans(y,na.rm = T)) %>%
          .[,Padj:=p.adjust(P)] %>%
          .[,type:=grp] %>%
        .[,gene:=icb.genes] 
        
    }
    all.stat.dt = data.table(do.call(rbind, all.stat))
    all.stat.dt
}


getz@meta.data %<>% 
cbind(.,
getz.resp[match(colnames(getz),V2)][,.(response=response.bin, treatment=treatment, drug=V7, Patient=V5)]) %>%
as.data.frame()

# getz.variablegenes<- Seurat::VariableFeatures(Seurat::FindVariableFeatures(getz, selection.method = "vst", nfeatures = 3500))
getz.variablegenes<- rownames(getz) 

getz.subset = intersect(getz.variablegenes, rownames(bcc.sco.subset)) %>%
getz[.,(getz@meta.data$drug=="anti-PD1") & (getz@meta.data$treatment=="pre")]

meta.data.curr = data.table(getz.subset@meta.data)%>%
.[,inx:=seq(.N)] %>%
.[,cluster:=assign.CIBERSORT]

getz.diff.exp.getz.dt = differential.expression.new(as.matrix(getz.subset[["RNA"]]@data), meta.data.curr)
getz.diff.exp.getz.dt1 = getz.diff.exp.getz.dt[,logFC:=responder.mean-nonresponder.mean] %>% 
.[,bulk.icb.deg:=icb.response.genes.dt[match(getz.diff.exp.getz.dt$gene, icb.response.genes.dt$genes)]$estimate]

getz.avi.dt = getz.diff.exp.getz.dt1[!is.na(P)][,logP:=-log10(P+1E-39)]
getz.avi.dt = getz.avi.dt[order(P)]
getz.avi.dt$label = ""
for (var in unique(getz.avi.dt$type)) {
     getz.avi.dt[type==var][1:20]$label = getz.avi.dt[type==var][1:20]$gene
}

library(ggrepel)
p.getz.scrna.volcano = ggplot(data=getz.avi.dt, aes(y=logP, x= logFC))  +
    geom_point(alpha=0.4,size=0.5) + 
      geom_text_repel(aes(label=label), size=2, alpha=0.8) +
    facet_wrap(~type, scales = "free") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
    # xlim(c(-1.2, 1.2)) + 
    theme(legend.position = "none")

ggsave(".figs/p.getz.scrna.volcano.pdf", p.getz.scrna.volcano, width=10, height=7)


p.getz.bulk.scrna = ggplot(data=getz.avi.dt, aes(y=bulk.icb.deg, x= logFC))  +
    geom_point(alpha=0.5,size=0.5) + 
      geom_text(aes(label=label), size=2, alpha=0.8) +
    facet_wrap(~type, scales = "free") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
    # xlim(c(-1.2, 1.2)) + 
    theme(legend.position = "none")

ggsave(".figs/p.getz.bulk.scrna.pdf", p.getz.bulk.scrna, width=10, height=7)


## pathway enrichment 
gene.eg.dt = clusterProfiler::bitr(unique(getz.diff.exp.getz.dt$gene), fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db") %>%
data.table(.) %>%
setkey(., SYMBOL) 

getz.diff.exp.getz.dt[,ENTREZID:= gene.eg.dt[match(getz.diff.exp.getz.dt$gene, SYMBOL)]$ENTREZID]%>%
.[, up_or_down:=ifelse(logFC > 0 , "upregulated", "downregulated")]
formula_res_scrna <- clusterProfiler::compareCluster(ENTREZID~up_or_down+type, data=getz.diff.exp.getz.dt[P< 1E-3][!is.na(up_or_down)], fun="clusterProfiler::enrichKEGG", organism="hsa", pvalueCutoff=0.05, universe=unique(getz.diff.exp.getz.dt$ENTREZID))
p = clusterProfiler::dotplot(formula_res_scrna, x=~type) + ggplot2::facet_grid(~up_or_down) + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
ggplot2::ggsave(filename = ".figs/p.getz.scrna.pathway.resp.noresp.pdf", p, width = 10, height = 10)

```


## Check if T-cell dysfunction + T-cell exclusion + Treg are better predictive of respose in CTLA4 cohort.
1. Check FOXP3 expression better predictor of response in CTLA4 cohort than PD1 cohort
2. Also run cox regression to check survival 

# Process gene names in Van Allen data
```{r}
# t(t(sapply(expression.mat.list, function(tt) "FOXP3" %in% colnames(tt))))

followup.curr = followups[["VanAllen2015_CTLA4_Melanoma_RNASeq"]]
sra.curr= fread("~/liulab_home/data/immunotherapy-trials/icb/my_SraRunTable/Mel_CTLA4_VanAllen_SRP011540_SraRunTable.txt") %>% 
.[,.(sra.name=Run, Patient.name=`Sample Name`)] %>%
.[,Patient:=sapply(Patient.name, function(tt) strsplit(tt, split="_")[[1]][4])]%>%
.[Patient %in% followup.curr$Patient]
# setdiff(followup.curr$Patient, sra.curr$Patient)]
expression.curr = fread("~/liulab_home/data/immunotherapy-trials/immunotherapy-trials/TPM/Mel_CTLA4_VanAllen.TPM")
	# colnames(expression.curr) %in% sra.curr$sra.name
sra.map  = sra.curr[match(colnames(expression.curr)[-1], sra.name),]
new.patient.name  = sra.map$Patient
emsembl2hgnc.dt = avinash::ensembl2hgnc()
gene.map = data.table(expression.curr$ENSEMBL_GeneID) %>%
  .[,V2:=sapply(V1, function(tt) strsplit(tt, split="\\.")[[1]][1])] %>% 
  .[,inx:=seq(.N)] %>% 
  .[,gene:=emsembl2hgnc.dt$hgnc_symbol[match(V2, emsembl2hgnc.dt$ensembl_gene_id)]] %>%
    .[!is.na(gene)] 
expression.sel = expression.curr[gene.map$inx] %>%
setnames(.,seq(ncol(expression.curr)), c("Symbol", new.patient.name)) %>%
.[,Symbol:=gene.map$gene] 

expression.new = apply(as.matrix(expression.sel[,-1,with=F]), 1, avinash::znorm)%>%
t() %>%
data.table() %>%
.[,Symbol:= expression.sel$Symbol] %>%
setcolorder(., colnames(expression.sel))


write.table(file = "~/liulab_home/data/immunotherapy-trials/icb/my_expression/VanAllen2015_CTLA4_Melanoma_RNASeq", x = expression.new, row.names = F, col.names = T,
sep = "\t", quote = F)
    expression.mat.list[["VanAllen2015_CTLA4_Melanoma_RNASeq"]]  =
    as.matrix(t(expression.new[,-1,with=F])) %>%
 set_colnames(expression.new$Symbol)


```
## Foxp3 analysis

```{r}
cal.auc.de = function(response, val){
	response = ifelse(response > 0,1,0)
	aa = pROC::auc(response, val, quiet=T, direction = "<")
	c(c(unlist(aa[[1]])), 
		mean(val[which(response==1)],na.rm=T),
		mean(val[which(response==0)],na.rm=T),
		(wilcox.test(val[which(response==1)], val[which(response==0)]))$p.value
		)
} 

foxp3.auc = lapply(dataset.name, function(ii){
	tryCatch({
exp.curr = expression.mat.list[[ii]][,"FOXP3"]
followups[[ii]][match(names(exp.curr), Patient)][["Response"]]%>%
 cal.auc.de(., exp.curr)
}, error = function(e) rep(NA,4))
})

col.names =  c("auc", "response.val", "nonresponse.val", "P")

foxp3.auc.dt = do.call(rbind, foxp3.auc) %>%
data.table() %>%
	.[,dataset:=c(dataset.name)] %>%
	setnames(., seq(4), col.names) %>%
	.[!is.na(P)]# %>%


p.predictor = ggplot(data=foxp3.auc.dt, aes(y = auc, x = as.factor(dataset)))  +
  geom_bar(stat="identity") + 
  geom_hline(yintercept = 0.5) +
  coord_flip() + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
  theme(legend.position = "none")

ggsave(filename=".figs/foxp3.auc.pdf", p.predictor)

## using CD3 as makers

cd3.genes = c( "CD3G", "CD3D",   "CD3E")

cd3.auc = lapply(dataset.name, function(ii){
	tryCatch({
		aa = expression.mat.list[[ii]]
cd3.curr= aa[,colnames(aa) %in% cd3.genes]
if(ncol(cd3.curr) > 0 ) cd3.curr = rowSums(cd3.curr,na.rm=T)
exp.curr = cd3.curr

followups[[ii]][match(names(exp.curr), Patient)][["Response"]]%>%
 cal.auc.de(., exp.curr)
}, error = function(e) rep(NA,4))
})

col.names =  c("auc", "response.val", "nonresponse.val", "P")

cd3.auc.dt = do.call(rbind, cd3.auc) %>%
data.table() %>%
	.[,dataset:=c(dataset.name)] %>%
	setnames(., seq(4), col.names) %>%
	.[!is.na(P)]# %>%


p.predictor = ggplot(data=cd3.auc.dt, aes(y = auc, x = as.factor(dataset)))  +
  geom_bar(stat="identity") + 
  geom_hline(yintercept = 0.5) +
  coord_flip() + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) + 
  theme(legend.position = "none")

ggsave(filename=".figs/cd3.auc.pdf", p.predictor)


## comparision of foxp3 and cd3 predictions 
foxp3.auc.dt$cd3.auc = cd3.auc.dt[match(foxp3.auc.dt$dataset, dataset)]$auc

library(ggrepel)
p.predictor = ggplot(data=foxp3.auc.dt, aes(y = auc, x = cd3.auc))  +
geom_point(color="red") + 
# geom_text(aes(label=dataset)) #+  
geom_text_repel(aes(label=dataset), size=3) +  
geom_abline(slope=1) +
xlab("CD3 auc") + ylab("FOXP3 auc") + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank()) + 
  theme(legend.position = "none") 

ggsave(filename=".figs/foxp3.cd3.auc.pdf", p.predictor)


```
## survival 
## PFS


```{r}
library(survival)
cal.cox = function(dtx){
    tryCatch(
        {
            dtx = dtx[!is.na(col)]
            aa =  coxph(Surv(Survival, Event) ~., dtx)
            summary(aa)$coefficients["col",c(1,5)]
        },
        error=  function(e) rep(NA,2),
        warning=  function(e) rep(NA,2)
)
}

cal.surv.de = function(followup.curr, exp){
	followup = followup.curr[match(rownames(exp), Patient)]
	foxp3.exp = exp[,"FOXP3"]
	cd3.curr= exp[,colnames(exp) %in% cd3.genes, drop=F]
	
	OS =  tryCatch(followup[,.(Survival=OS, Event=OS.Event)],
		error=  function(e) NA)
	OS.foxp3 = tryCatch({
		OS[,col:=foxp3.exp] %>%
	cal.cox()	
	}, error=function(e) rep(NA,2))
	OS.foxp3.res = tryCatch({
		OS[,col:=foxp3.exp] %>%
		cbind(.,cd3.curr)%>%
	cal.cox()	
	}, error=function(e) rep(NA,2))


	PFS =  tryCatch(followup[,.(Survival=PFS, Event=PFS.Event)],
		error=  function(e) NA)
	PFS.foxp3 = tryCatch({
		PFS[,col:=foxp3.exp] %>%
	cal.cox()	
	}, error=function(e) rep(NA,2))
	PFS.foxp3.res = tryCatch({
		PFS[,col:=foxp3.exp] %>%
		cbind(.,cd3.curr)%>%
	cal.cox()	
	}, error=function(e) rep(NA,2))

c(
	OS.foxp3, OS.foxp3.res,
	PFS.foxp3, PFS.foxp3.res
	)

} 


foxp3.surv = lapply(dataset.name, function(ii)
 tryCatch(cal.surv.de(followups[[ii]], expression.mat.list[[ii]]),
 error=function(e) NA)
 )

names(foxp3.surv) = dataset.name
foxp3.surv = foxp3.surv[!is.na(foxp3.surv)]

col.names =  paste(c("coef", "P"), rep(c("OS", "OS.res", "PFS", "PFS.res"), each=2),sep="_")
foxp3.surv.dt = do.call(rbind, foxp3.surv) %>%
data.table() %>%
	.[,dataset:=names(foxp3.surv)] %>%
	setnames(., seq(length(col.names)), col.names) 


p.predictor = ggplot(data=foxp3.surv.dt, aes(y = coef_OS, x = coef_OS.res))  +
geom_point(color="red") + 
# geom_text(aes(label=dataset)) #+  
geom_text_repel(aes(label=dataset), size=2) +  
geom_abline(slope=1) +
xlab("FOXP3 OS (control for CD3)") + ylab("FOXP3 OS") + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank()) + 
  theme(legend.position = "none") 

ggsave(filename=".figs/foxp3.cd3.OS.pdf", p.predictor)

```
# need to run ICB response with best response. Also reanalze Van Allen data 

```{r}
eg2hugo = function(tt){
    gene.eg.dt = clusterProfiler::bitr(unique(tt), toType="SYMBOL", fromType="ENTREZID", OrgDb="org.Hs.eg.db")
    gene.eg.dt[match(tt, gene.eg.dt$ENTREZID),]$SYMBOL
}
read.exp = function(expression.file) {
    aa = fread(expression.file)
    genes.curr= aa$Symbol
    if (all(is.numeric(genes.curr))){
        ## if entrez genes
        genes.curr = eg2hugo(genes.curr)
    }
    exp.mat = as.matrix(t(aa[,-1,with=F]))
    colnames(exp.mat) = genes.curr
    exp.mat = exp.mat[,!is.na(genes.curr)]

    exp.mat = apply(exp.mat,2,avinash::znorm)
    exp.mat
}
van.allen.exp = read.exp("/homes6/asahu/liulab_home/data/ssgsea/xiaoman/icb/expression//VanAllen2015_CTLA4_Melanoma_RNASeq")

expression.mat.list[["VanAllen2015_CTLA4_Melanoma_RNASeq"]]  = van.allen.exp
genes.curr = fread("~/project/deeplearning/icb/data/icb/scrna_transer/howard/dataset_val.txt")[1]
genes.curr = colnames(genes.curr)[seq(2,ncol(genes.curr)-1)]

dataset.curr = "VanAllen2015_CTLA4_Melanoma_RNASeq"
icb.response.dt.curr = icb.response.dt[dataset==dataset.curr][match(rownames(van.allen.exp),Patient)]

expression.icb.sel = van.allen.exp[,match(genes.curr, colnames(van.allen.exp))]
expression.icb.sel[is.na(expression.icb.sel)] = 0

icb.dataset.curr = data.table(cbind(cancertype=dataset.curr, expression.icb.sel, response=icb.response.dt.curr$response))
dataset.dir = sprintf("~/project/deeplearning/icb/data/icb/scrna_transer/%s", dataset.curr)
avinash::write.dataset(output.dir = dataset.dir, dataset = icb.dataset.curr, sample.name = icb.response.dt.curr[,paste(Patient, dataset)])


temp1 = data.table(bcc.sco@meta.data)
temp2 = as.matrix(bcc.sco[["RNA"]]@data)
save(file="~/temp.RData", temp1, temp2,variable.genes.sel)

predictor_celltype_dir= list.files(path="~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/", pattern = "^vargene_", full.names=T)
for (ct.dir in predictor_celltype_dir) {
    command = sprintf("CUDA_VISIBLE_DEVICES=2 python evaluate.py  --data_dir  ~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_test_list.txt --model_dir ~/project/deeplearning/icb/data/icb/scrna_transer/howard/. --restore_file %s/best.pth.tar  --output_dir %s/all.icb", ct.dir,ct.dir)
    system(command = command, wait = T,ignore.stdout = F)
}

```
## UMAP for scRNA  + Tcga-immune-phenotype on all ICB cohorts.

```{r}
# phenotypes.predicted from TCGA 
# scRNA response predicted 
predictor_celltype_dir= list.files(path="~/project/deeplearning/icb/data/icb/scrna_transer/howard/tensorboardLog/", pattern = "^vargene_", full.names=T)
csv.datas = list()
for (ct.dir in predictor_celltype_dir) {
  temp = basename(ct.dir)
  cell.type = substring(temp, 9, nchar(temp) - 16)
  test.dir = sprintf("%s/all.icb", ct.dir)
  csv.datas[[cell.type]] = do.call(rbind, lapply(list.files(path=test.dir, pattern="^val", full.names = T), function(tt) {
    fread(tt) %>%
    .[,label:=basename(tt)]
  }))
}
scrna.dataset.list = fread("~/project/deeplearning/icb/data/icb/scrna_transer/howard/datasets_test_list.txt")$prefix
scrna.test.meta.info = do.call(rbind, lapply( seq(length(scrna.dataset.list)), function(tt){
    dataset.curr = scrna.dataset.list[tt]
    sprintf("~/project/deeplearning/icb/data/icb/scrna_transer/%s/samples_name.txt", dataset.curr) %>%
    fread(.,skip=1,sep=" ", header=F) %>%
    # .[,dataset:=dataset.curr] %>%
    .[,inx:=tt] %>%
    .[,file:=sprintf("val_%s_prediction.csv", tt)]
}))
scrna.predicted = data.table(do.call(cbind, lapply(csv.datas, function(tt) tt$response.output))) %>%
set_colnames(names(csv.datas))



library(uwot)
library(ggplot2)
umap.model <- umap(scrna.predicted, pca = NULL, ret_model = T)
d_umap = cbind(scrna.test.meta.info[,.(patient=V1, dataset=V2)], data.table(umap.model$embedding)) %>%
cbind(., response=csv.datas[[1]]$response)
create.text = function(tt) gsub(".csv", gsub("best_val_", tt, replacement=""),replacement="")
p = ggplot(d_umap[dataset=="Mariathasan2018_PDL1_Bladder_RNASeq_mUC"], aes(x = V1, y = V2)) + 
  geom_point(aes(color = as.factor(response)), alpha = 0.8) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic() 

ggsave(".figs/umap.scrna.predicted.response.pdf", p)

```
```{r}
phenotypes.predicted.matched.scrna = lapply(dataset.name, function(tt){
    d_umap.curr = d_umap[dataset==tt] 
    meta.info.curr = meta.info.dt[names==tt]
    followups.curr = followups[[tt]][match(d_umap.curr$patient, Patient)]
    setnames(followups.curr,1, "Patient")
    # intersect.patient = intersect(meta.info.curr$Patient, followups.curr$Patient)
    meta.info.matched = meta.info.curr[match(followups.curr$Patient,Patient)]
    if(nrow(d_umap.curr) !=nrow(meta.info.matched)){
        print(tt)
    }
    phenotypes.predicted[meta.info.matched$inx,]
}) %>% 
do.call(rbind, .)

bulk.umap.model <- umap(phenotypes.predicted.matched.scrna, ret_model = T)
d_bulk.umap = cbind(scrna.test.meta.info[,.(patient=V1, dataset=V2)], data.table(bulk.umap.model$embedding)) %>%
cbind(., response=csv.datas[[1]]$response) %>%
.[,label:=as.factor(dataset)]
levels(d_bulk.umap$label) = LETTERS[seq(length(unique(d_bulk.umap$dataset)))]


p = ggplot(d_bulk.umap, aes(x = V1, y = V2)) + 
  geom_text(aes(color = as.factor(response), label = label), alpha = 0.8) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic()
ggsave(".figs/umap.bulk.predicted.response.pdf", p)

p = ggplot(d_bulk.umap, aes(x = V1, y = V2)) + 
  geom_point(aes(color = as.factor(dataset)), alpha = 0.8) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic()
ggsave(".figs/umap.bulk.predicted.dataset.pdf", p)
## combined

combined.umap.model <- umap(cbind(phenotypes.predicted.matched.scrna, scrna.predicted), ret_model = T)
d_combined.umap = cbind(scrna.test.meta.info[,.(patient=V1, dataset=V2)], data.table(combined.umap.model$embedding)) %>%
cbind(., response=csv.datas[[1]]$response)
p = ggplot(d_combined.umap, aes(x = V1, y = V2)) + 
  geom_point(aes(color = as.factor(response)), alpha = 0.8) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic()
ggsave(".figs/umap.bulk.scrna.combined.predicted.response.pdf", p)



## only the expression
dataset.sel = dataset.name[sapply(expression.mat.list, function(tt) ncol(tt) > 15000)]
genes.considered  = sapply(dataset.sel, function(tt) colnames(expression.mat.list[[tt]]))%>%
unlist() %>%
table() %>%
.[.==length(dataset.sel)] %>%
names()

exp.curr = do.call(rbind, sapply(dataset.sel, function(tt) expression.mat.list[[tt]][,genes.considered], simplify = F))
icb.response.dt.sel = icb.response.dt[dataset %in% dataset.sel] %>% 
.[,label:=paste(Patient, dataset)] %>% 
.[label %in% meta.info.dt$label]
meta.info.dt.sel = meta.info.dt[names %in% dataset.sel] 

exp.curr= exp.curr[match(icb.response.dt.sel[,paste(Patient, dataset), ], meta.info.dt.sel$label),]
exp.curr= exp.curr[,which(colSums(is.na(exp.curr))==0)]
exp.curr = exp.curr[, colnames(exp.curr) %in% icb.response.genes.dt[1:2000]$genes]
# tt= "Mariathasan2018_PDL1_Bladder_RNASeq_mUC"
bulk.umap.model.exp <- umap(exp.curr)
d_bulk.umap = cbind(icb.response.dt.sel[,.(patient=Patient, dataset=dataset, response=Response)], data.table(bulk.umap.model.exp)) %>%
.[,label:=as.factor(dataset)]
levels(d_bulk.umap$label) = LETTERS[seq(length(unique(d_bulk.umap$dataset)))]
p = ggplot(d_bulk.umap, aes(x = V1, y = V2)) + 
  # geom_point(aes(color = as.factor(response)), alpha = 0.8) +
  geom_text(aes(color = as.factor(response), label = label), alpha = 0.7, size=2) +
  guides(colour = guide_legend(override.aes = list(size = 2))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic()
ggsave(".figs/umap.expression.response.pdf", p)


d_bulk.sel = d_bulk.umap[label!="I" ]
pROC::auc(d_bulk.sel$response, d_bulk.sel$V1)

```


## Howard change data

```{r}
library(Seurat)
library(ggplot2)
library(Matrix)
options(bitmapType='cairo')
 infile <- Read10X_h5('~/liulab_home/data/single_cell/LECR_GSE139555/Data/LECR_GSE139555_gene_count.h5')
  # infile <- infile[rowSums(infile)>10,colSums(infile)>500]
  meta <- read.table('~/liulab_home/data/single_cell/LECR_GSE139555/Data/LECR_GSE139555_metadata.txt')
#  expr <- RNACountToTPM(as.matrix(infile), idType="Symbol")
#  expr <- log2(expr/10+1)
  LECR.RNA.res <- readRDS("~/liulab_home/data/single_cell/LECR_GSE139555/LECR_GSE123139_res.rds")

  # clustering
  LECR.RNA.res <- RNARunSeurat(inputMat = infile,
                               project = "LECR_GSE123139",
                               min.c = 10,
                               min.g = 500,
                               dims.use = 1:15,
                               variable.genes = 2000,
                               organism = "GRCh38",
                               cluster.res = 0.6,
                               genes.test.use = "wilcox",
                               genes.cutoff = 1e-05)

```

```{r}
library(Matrix)
library(Seurat)
library(data.table)
library(magrittr)
library(cowplot)
library(harmony)
library(uwot)
library(parallel)
exp.file = list.files(path = "~/liulab_home/data/single_cell/GSE145281/", pattern="*raw.txt.gz", full.names=T) %>%
grep(pattern="R[1-5]", value=T)
GSE145281.list = lapply(exp.file, function(tt){
    aa = fread(tt)
    aa[,-1,with=F] %>% 
    as.matrix() %>%
    t()%>%
    set_colnames(aa[[1]])%>%
    Matrix(data=., sparse=T)%>%
    list(exp=.,samples=rownames(.), genes=colnames(.))
}
    )
GSE145281.exp.mat= sapply(GSE145281.list, function(tt) tt$exp, simplify=F) %>%
do.call(rbind,.)
GSE145281.meta = lapply(seq(length(exp.file)),  function(tt) {
    patient.curr= basename(exp.file[[tt]]) %>%
    strsplit(x=., split="_")%>% 
    unlist() %>%.[2]
    response = substring(patient.curr,1,1) %>%
    equals("R")+0
    data.table(samples=GSE145281.list[[tt]]$samples, patient=patient.curr, response=response)
}) %>% do.call(rbind, .)

GSE145281.umap.model.exp <- umap(as.matrix(GSE145281.exp.mat), pca=50, n_threads=32)
d_GSE145281.umap = cbind(GSE145281.meta[,.(patient=patient, response=response)], data.table(GSE145281.umap.model.exp)) %>%
.[,label:=as.factor(patient)]
levels(d_GSE145281.umap$label) = LETTERS[seq(length(unique(d_GSE145281.umap$label)))]
p = ggplot(d_GSE145281.umap, aes(x = V1, y = V2)) + 
  geom_point(aes(color = as.factor(label)), alpha = 0.5, size=0.5) +
  # geom_text(aes(color = as.factor(response), label = label), alpha = 0.7, size=2) +
  guides(colour = guide_legend(override.aes = list(size = 1))) + 
  xlab("umap_1") + ylab("umap_2")  +
  theme_classic()
ggsave(".figs/GSE145281.umap.expression.pdf", p)


# patient specific correction 
gse145281 <- CreateSeuratObject(counts = t(GSE145281.exp.mat), project = "GSE145281", min.cells = 5) %>%
    Seurat::NormalizeData(verbose = FALSE) %>%
    FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>% 
    ScaleData(verbose = FALSE) %>% 
    RunPCA(pc.genes = pbmc@var.genes, npcs = 20, verbose = FALSE)

GSE145281.meta.match = GSE145281.meta[match(rownames(gse145281@meta.data), samples)]
gse145281@meta.data %<>% cbind(., GSE145281.meta.match[,.(patient, response)]) %>%
as.data.frame()  

options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = gse145281, reduction = "pca", pt.size = .1, group.by = "patient", do.return = TRUE)
p2 <- VlnPlot(object = gse145281, features = "PC_1", group.by = "patient", do.return = TRUE, pt.size = .1)
pdf(".figs/gse145281.without.harmony.pdf")
# plot_grid(p1,p2)
print(p1)
dev.off()

gse145281 <- gse145281 %>% 
    RunHarmony("patient")


harmony_embeddings <- Embeddings(gse145281, 'harmony')
harmony_embeddings[1:5, 1:5]

options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = gse145281, reduction = "harmony", pt.size = .1, group.by = "patient", do.return = TRUE)
p2 <- VlnPlot(object = gse145281, features = "harmony_1", group.by = "patient", do.return = TRUE, pt.size = .1)

pdf(".figs/gse145281.harmony.pdf")
# plot_grid(p1,p2)
print(p1)
dev.off()

gse145281[["umapunorm"]] = gse145281@reductions$pca@cell.embeddings %>% 
umap(., n_threads=32, metric="cosine", pca=NULL, n_neighbors=50) %>%
set_rownames(colnames(gse145281)) %>%
set_colnames(paste0("umapunorm_", 1:2)) %>%
CreateDimReducObject(embeddings = ., key = "umapunorm_", assay = DefaultAssay(gse145281))

DimPlot(gse145281, reduction = "umapunorm", group.by = "patient", pt.size = 0.5)%>%
ggsave(filename=".figs/gse145281.umap.without.harmony.pdf", plot=.)

gse145281 <- gse145281 %>% 
    RunUMAP(reduction = "harmony", dims = 1:20) %>% 
    FindNeighbors(reduction = "harmony", dims = 1:20) %>% 
    FindClusters(resolution = 0.5) %>% 
    identity()

DimPlot(gse145281, reduction = "umap", group.by = "patient", pt.size = .1, split.by = 'patient') %>%
ggsave(".figs/gse145281.harmony.umap.patient.pdf", plot=.)

DimPlot(gse145281, reduction = "umap", group.by = "patient", label = TRUE, pt.size = .1) %>%
ggsave(".figs/gse145281.harmony.umap.pdf", plot=.)

DimPlot(gse145281, reduction = "umap", label = TRUE, pt.size = .1) %>%
ggsave(".figs/gse145281.harmony.umap.cluster.pdf", plot=.)

## 
p1 = DimPlot(gse145281, reduction = "umap", group.by = "response", pt.size = .1, split.by = 'response')
pdf(".figs/gse145281.harmony.umap.response.pdf")
plot_grid(p1)
dev.off()


## response 

if(F) {
    library(dplyr)
library(ggplot2)
gse145281.markers <- FindAllMarkers(gse145281, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
gse145281.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)

top10 <- gse145281.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
p =  DoHeatmap(gse145281, features = top10$gene) + NoLegend()
ggsave(file=".figs/gse145281.harmony.markers.pdf", p, width=15, height=10)

p = FeaturePlot(gse145281, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
    "CD8A", "GZMB", "PRF1", "IL7R", "CCR7", "CD4"))
ggsave(file=".figs/gse145281.harmony.features.pdf", p, width=15, height=10)
}
# find differential expression between responders and non responder in a cell population. 
# For a gene differntially expressed in responders show that it is specific to a patient i.e.  R1 vs. rest-of-responders 
# argue that this is a confounding effect and need to be corrected in every analysis
# there is need a tool for this 
## cluster 6 is B-cells 

out = gse145281@meta.data %>%
data.table() %>% 
.[,.N, by=list(seurat_clusters,patient) ] %>%
dcast(data = .,formula = seurat_clusters~patient,value.var="N",fun.aggregate = sum)


#clust 1 confounders
gse145281.clust = gse145281[,gse145281$seurat_clusters==1]
markers <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = 0.05, logfc.threshold = 0.15)
## confounding markers
gse145281.confound = gse145281.clust[,gse145281.clust$response==0]
markers.confound <- FindMarkers(gse145281.confound, ident.1 = "NR1", group.by = 'patient', min.pct = 0.05, logfc.threshold = 0.15)
markers.intersect = intersect(rownames(markers[markers$avg_logFC>0,])[1:50], rownames(markers.confound)[1:200])
VlnPlot(gse145281.clust, markers.intersect, group.by = 'patient') %>%
ggsave(file=".figs/gse145281.clust1.markers.pdf", ., width=15, height=10)
markers.common  = intersect(rownames(markers), rownames(markers.confound))
markers.merge = markers.confound %>%
set_colnames(paste0(colnames(markers.confound), ".nr1"))%>% 
.[markers.common,] %>%
cbind(., markers[markers.common,]) 
markers.merge$genes=rownames(markers.merge)
markers.merge = data.table(markers.merge)
markers.merge[,avg_logFC_r:=rank(avg_logFC)][,avg_logFC.nr1_r:=rank(avg_logFC.nr1)]
library(ggpubr)
p = ggplot(markers.merge, aes(x=avg_logFC,y=avg_logFC.nr1)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("R vs. NR") + ylab("NR1 vs. other-NR")
ggsave(file=".figs/gse145281.clust1.confound.pdf", p)


```
## implement the control for patients
## https://www.biorxiv.org/content/10.1101/2020.01.15.906248v1.full.pdf
# make sure there is issue with 
```{r}
one_hot.mat = gse145281@meta.data %>%
data.table(ID=rownames(.)) %>%
.[,list(ID,patiient=factor(patient))] %>%
mltools::one_hot(.)
gse145281@meta.data %<>% cbind(., one_hot.mat[,-1, with=F]) %>%
as.data.frame() 
patient.latent.vars = colnames(one_hot.mat)[-1]

# clust 2
gse145281.clust = gse145281[,gse145281$seurat_clusters==2]
markers <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = 0.25, logfc.threshold = 0.15)
markers.mast <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = 0.25, logfc.threshold = 0.15, test.use="MAST")
markers.mast.patient <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = 0.25, logfc.threshold = 0.15, test.use="MAST", latent.vars=patient.latent.vars)
gse145281.confound = gse145281.clust[,gse145281.clust$response==1]
markers.confound <- FindMarkers(gse145281.confound, ident.1 = "R3", group.by = 'patient', min.pct = 0.25, logfc.threshold = 0.15)
markers.intersect = intersect(rownames(markers[markers$avg_logFC>0,])[1:50], rownames(markers.confound)[1:30])
VlnPlot(gse145281.clust, markers.intersect, group.by = 'patient') %>%
ggsave(file=".figs/gse145281.clust2.markers.pdf", ., width=15, height=10)

markers.common  = intersect(rownames(markers), rownames(markers.confound))
markers.merge = markers.confound %>%
set_colnames(paste0(colnames(markers.confound), ".r3"))%>% 
.[markers.common,] %>%
cbind(., markers[markers.common,]) 
markers.merge$genes=rownames(markers.merge)
markers.merge = data.table(markers.merge)
markers.merge[,avg_logFC_r:=rank(avg_logFC)][,avg_logFC.r3_r:=rank(avg_logFC.r3)]
library(ggpubr)
p = ggplot(markers.merge, aes(x=avg_logFC,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("R vs. NR") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.confound.pdf", p)

## 
markers.common  = intersect(rownames(markers.mast.patient), rownames(markers.confound))
markers.merge = markers.confound %>%
set_colnames(paste0(colnames(markers.confound), ".r3"))%>% 
.[markers.common,] %>%
cbind(., markers.mast.patient[markers.common,]) 
markers.merge$genes=rownames(markers.merge)
markers.merge = data.table(markers.merge)
# markers.merge[,avg_logFC_r:=rank(avg_logFC)][,avg_logFC.r3_r:=rank(avg_logFC.r3)]
markers.merge[,deg:=log(p_val + 1E-30) *sign(avg_logFC)] %>%
.[,deg.r3:=log(p_val.r3 + 1E-30) *sign(avg_logFC.r3)]

p = ggplot(markers.merge, aes(x=deg,y=deg.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("R vs. NR") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.pseudoreplication.pdf", p)
```

## Proposing the solution of patient specific confounding effects. 
# 1. Leverage cluster level in DEG. The cluster DEG could be used to 
# Y ~ Beta|cluster + 1|patient 1|cluster 

```{r}
genes.curr = gse145281[["RNA"]]@var.features
exp.curr = gse145281[["RNA"]][genes.curr,]
meta.dt = gse145281@meta.data %>% 
data.table(ID=rownames(.)) %>%
.[,.(ID, response, patient=as.factor(patient), cluster=as.factor(seurat_clusters))]


eval.lmer.solution = function(dt.curr, val){
    tryCatch({
    dt.curr = dt.curr %>%
    mutate(exp=val)
    aa = lme4::lmer(data=dt.curr, exp~ response + (1+response|cluster) + (1|patient))
    bb = coef(aa)
    c(unlist(bb$cluster), bb$patient[,2])
}, error = function(e) rep(NA,42))
}

library(parallel)
out = mclapply(seq(nrow(exp.curr)), function(tt) 
    eval.lmer.solution(meta.dt, exp.curr[tt,]),
    mc.cores=48
    )

out.dt = do.call(rbind, out)

cluster.markers = (out.dt[,1:16] - rowMeans(out.dt[,1:16])) %>%
set_colnames(paste0("cluster_", 0:15)) %>%
data.table() %>%
mutate(gene=rownames(exp.curr)) %>%
data.table()
cluster.markers = cluster.markers[order(cluster_0, decreasing=T)]

responder.markers = (out.dt[,17:32]) %>%
set_colnames(paste0("cluster_", 0:15)) %>%
data.table() %>%
mutate(gene=rownames(exp.curr)) %>%
data.table()
head(responder.markers[order(cluster_2, decreasing=T)]$gene)

gse145281.clust = gse145281[,gse145281$seurat_clusters==2] %>%
.[gse145281[["RNA"]]@var.features,]
markers <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = -1, logfc.threshold = -1)
gse145281.confound = gse145281.clust[,gse145281.clust$response==1]
markers.confound <- FindMarkers(gse145281.confound, ident.1 = "R3", group.by = 'patient', min.pct = -1, logfc.threshold = -1)
markers.common  = intersect(rownames(markers), rownames(markers.confound))
markers.merge = markers.confound %>%
set_colnames(paste0(colnames(markers.confound), ".r3"))%>% 
.[markers.common,] %>%
cbind(., markers[markers.common,]) 
markers.merge$genes=rownames(markers.merge)
markers.merge = data.table(markers.merge)
markers.merge[,avg_logFC_r:=rank(avg_logFC)][,avg_logFC.r3_r:=rank(avg_logFC.r3)]
markers.merge$model1=responder.markers[match(markers.merge$genes,gene)]$cluster_2

library(ggpubr)
p = ggplot(markers.merge, aes(x=-model1,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model1 (R vs. NR)") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.model1.pdf", p)

p = ggplot(markers.merge, aes(x=-model1,y=avg_logFC)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model1 (R vs. NR)") + ylab("Seurat (R vs. NR)")
ggsave(file=".figs/gse145281.clust2.model1.comparison.seurat.pdf", p)

markers.deseq2 <- FindMarkers(gse145281.clust, ident.1 = "0", group.by = 'response', min.pct = -1, logfc.threshold = -1, test.use="DESeq2")


markers$avg_logFC.effect = -markers$avg_logFC

library(EnhancedVolcano)
 EnhancedVolcano(markers,
                             lab = rownames(markers),
                             x = 'avg_logFC.effect',
                             y = 'p_val_adj',
                             pCutoff = 1e-2,
                             FCcutoff = .5,
                             # ylim = c(0,5.2),
                             # xlim = c(-1, 1),
                             # pointSize = 4.0,
                             pointSize = c(ifelse(markers$p_val_adj< 1E-10, 1, 0.2)),
                             labSize = 4.0,
                             legend=c('NS','Log (base 2) fold-change','Adj.P value',
                                      'Adj.P value & Log (base 2) fold-change'),
                             legendPosition = 'right',
                             legendLabSize = 8,
                             legendIconSize = 4.0,
                             drawConnectors = TRUE,
                             widthConnectors = 0.2,
                             colAlpha = 0.8,
                             colConnectors = 'grey30'
) %>%
ggsave(".figs/gse145281.clust2.volcano.wilcox.pdf", .)

```

## Model 2 
## check the method can identify markers of cluster 

```{r}
meta.dt = gse145281@meta.data %>% 
data.table(ID=rownames(.)) %>%
.[,.(ID, response, patient=as.factor(patient), cluster=as.factor(seurat_clusters), 
    nCount_RNA = avinash::normalize.std(nCount_RNA),
     nFeature_RNA = avinash::normalize.std(nFeature_RNA))]
meta.dt.curr = meta.dt[,.(ID, cluster)]  %>%
mltools::one_hot(.) %>%
.[,-1,with=F] %>%
cbind(meta.dt, .) 

library(lme4)
eval.lmer.marker = function(dt.curr, val, fmla){
    tryCatch({
    dt.curr = dt.curr %>%
    mutate(GENE=val)
    aa = lmer(data=dt.curr, fmla)
    preds = predict(aa, newdata=dt.curr)
    preds
}, error = function(e) NA
)
}
latent.var.names  = c(
    grep("cluster_", colnames(meta.dt.curr), value=T),
     "nCount_RNA", "nFeature_RNA")
fmla <- as.formula(object = paste(
  "GENE ~",
  paste(latent.var.names[-1], collapse = "+"),
  "+(1|patient)"
  ))

out.models = mclapply(seq(nrow(exp.curr)), function(tt) 
    eval.lmer.marker(meta.dt.curr, exp.curr[tt,], fmla),
    mc.cores =48
    )
preds.patients.cluster = do.call(rbind, out.models)

exp.curr.clust  = exp.curr[,meta.dt.curr$cluster==2]
preds.patients.cluster.clust = preds.patients.cluster[,meta.dt.curr$cluster==2]
response.clust = meta.dt[cluster==2]$response
out.final = mclapply(seq(nrow(exp.curr)), function(tt){
    tryCatch({
    aa = lm(exp.curr.clust[tt,]~ response.clust + preds.patients.cluster.clust[tt,])
    summary(aa)$coefficients["response.clust",]
}, error=function(e) NA)
},mc.cores =48
    )
out.final.clust2 = do.call(rbind, out.final) %>%
data.table() %>%
set_colnames(c("estimate","se", "t", "P")) %>%
mutate(p.adj=p.adjust(P))  %>%
mutate(gene=rownames(exp.curr)) %>%
data.table() %>%
.[order(P)]

markers.merge$model2=out.final.clust2[match(markers.merge$genes,gene)]$t

library(ggpubr)
p = ggplot(markers.merge, aes(x=-model2,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model2 (R vs. NR)") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.model2.pdf", p)

p = ggplot(markers.merge, aes(x=-model2,y=avg_logFC)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model2 (R vs. NR)") + ylab("Seurat (R vs. NR)")
ggsave(file=".figs/gse145281.clust2.model2.comparison.seurat.pdf", p)

model2.effects = do.call(rbind, out.models) 
dimnames(model2.effects) = dimnames(exp.curr)
model2.effects = CreateSeuratObject(counts = model2.effects, meta.data = gse145281@meta.data)
label = "model2"
model2.effects.clust = model2.effects[,model2.effects$seurat_clusters==2]

```



## model 3
```{r}

library(lme4)
eval.lmer.marker = function(dt.curr, val, fmla){
    tryCatch({
    dt.curr = dt.curr %>%
    mutate(GENE=val)
    aa = lmer(data=dt.curr, fmla)
    dt.curr$response = 0
    preds = predict(aa, newdata=dt.curr)
    preds
}, error = function(e) NA
)
}
latent.var.names  = c(
    grep("cluster_", colnames(meta.dt.curr), value=T),
     "nCount_RNA", "nFeature_RNA")
fmla <- as.formula(object = paste(
  "GENE ~",
  paste(latent.var.names, collapse = "+")[-1],
  "+(1|patient) + (1|response)"
  ))

out.model3.models = mclapply(seq(nrow(exp.curr)), function(tt) 
    eval.lmer.marker(meta.dt.curr, exp.curr[tt,], fmla),
    mc.cores =48
    )
preds.patients.cluster = do.call(rbind, out.model3.models)

exp.curr.clust  = exp.curr[,meta.dt.curr$cluster==2]
preds.patients.cluster.clust = preds.patients.cluster[,meta.dt.curr$cluster==2]
response.clust = meta.dt[cluster==2]$response
out.model3.final = mclapply(seq(nrow(exp.curr)), function(tt){
    tryCatch({
    aa = lm(exp.curr.clust[tt,]~ response.clust + preds.patients.cluster.clust[tt,])
    summary(aa)$coefficients["response.clust",]
}, error=function(e) NA)
},mc.cores =48
    )
out.model3.final.clust2 = do.call(rbind, out.model3.final) %>%
data.table() %>%
set_colnames(c("estimate","se", "t", "P")) %>%
mutate(p.adj=p.adjust(P))  %>%
mutate(gene=rownames(exp.curr)) %>%
data.table() %>%
.[order(P)]

markers.merge$model3=out.model3.final.clust2[match(markers.merge$genes,gene)]$estimate

library(ggpubr)
p = ggplot(markers.merge, aes(x=-model3,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model3 (R vs. NR)") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.model3.pdf", p)

p = ggplot(markers.merge, aes(x=-model3,y=avg_logFC)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model3 (R vs. NR)") + ylab("Seurat (R vs. NR)")
ggsave(file=".figs/gse145281.clust2.model3.comparison.seurat.pdf", p)


## Visually verify that which one is better 
## Assume that if it occurs in two samples that unlikely false-positive
gse145281.clust = gse145281[,colnames(exp.curr.clust)]
VlnPlot(gse145281.clust, markers.intersect, group.by = 'patient') %>%
ggsave(file=".figs/gse145281.clust2.markers.pdf", ., width=15, height=10)
save.image(file=".figs/gse145281.RData")

```

## Implementation of psuedo-bulk method from : https://www.biorxiv.org/content/10.1101/2020.04.01.019851v1 

```{r}
gse145281.clust = gse145281[,gse145281$seurat_clusters==2]
patient.cell.one.hot= gse145281.clust@meta.data %>% 
data.table(ID=rownames(.)) %>%
.[,.(ID, patient=as.factor(patient))] %>%
.[,.(ID, patient)]  %>%
mltools::one_hot(.) %>%
.[,-1,with=F] %>%
as.matrix() 

psuedo.bulk = gse145281.clust@assays$RNA@counts %*% patient.cell.one.hot

cells.1 = grep("_R", colnames(psuedo.bulk), value=T)
cells.2 = grep("_NR", colnames(psuedo.bulk), value=T)
deseq.out = DESeq2DETest(data.use=psuedo.bulk, cells.1=cells.2, cells.2=cells.1)
deseq.dt = deseq.out %>%
as.data.frame() %>%
mutate(gene=rownames(.)) %>%
data.table() 
deseq.dt = deseq.dt[order(padj)]
deseq.dt.matched = deseq.dt[match(markers.merge$gene,gene)]

markers.merge$pseudoBulk=deseq.dt[match(markers.merge$genes,gene)]$stat
cor.test(out.final.clust2$t, deseq.dt[match(out.final.clust2$gene,gene)]$stat, method="spearman")
cor(markers.merge[,12:17,with=F], use = "pairwise.complete.obs")
## check top 25 candidates of each 
# effect size and p-values
for (ii in seq(12,17)) {
    label = colnames(markers.merge)[ii]
    genes.curr = order(abs(markers.merge[[label]]), decreasing=T)[1:16] %>%
    markers.merge[.] %>%
    .[["genes"]]
    VlnPlot(gse145281.clust, genes.curr, group.by = 'patient') %>%
    ggsave(file=sprintf(".figs/gse145281.clust2.%s.pdf", label), ., width=15, height=10)
}

genes.curr = deseq.dt[order(abs(stat), decreasing=T)[1:16]]$gene

VlnPlot(gse145281.clust, genes.curr, group.by = 'patient') %>%
ggsave(file=sprintf(".figs/gse145281.clust2.%s.nonvariablegenes.pdf", "psuedoBulk"), ., width=15, height=10)


## Evaluate the model2 vs. psuedobulk 
genes.curr = order(abs(markers.merge[[label]]), decreasing=T)[1:16] %>%
markers.merge[.] %>%
.[["genes"]]
VlnPlot(model2.effects.clust, genes.curr, group.by = 'patient') %>%
ggsave(file=sprintf(".figs/gse145281.clust2.%s.patients.predicted.pdf", label), ., width=15, height=10)
## Identifying genes that are correctly identified by psuedoBulk but not by model2 
genes.curr = setdiff(deseq.dt.matched[which(padj < 8E-2)]$gene, out.final.clust2[which(p.adj < 1E-3)]$gene)
VlnPlot(model2.effects.clust, genes.curr, group.by = 'patient') %>%
ggsave(file=sprintf(".figs/gse145281.clust2.%s.patients.predicted.compare.psuedobulk.pdf", label), ., width=15, height=10)

VlnPlot(gse145281.clust, genes.curr, group.by = 'patient') %>%
ggsave(file=sprintf(".figs/gse145281.clust2.%s.compare.psuedobulk.pdf", label), ., width=15, height=10)

```



## Using the psuedo-bulk as prior (model4) 

## run deseq for each cluster
```{r}

deseq.all.out = lapply(sort(unique(gse145281$seurat_clusters)), function(tt) {
    tryCatch({
    gse145281.clust = gse145281[,gse145281$seurat_clusters==tt]
    patient.cell.one.hot= gse145281.clust@meta.data %>% 
    data.table(ID=rownames(.)) %>%
    .[,.(ID, patient=as.factor(patient))] %>%
    .[,.(ID, patient)]  %>%
    mltools::one_hot(.) %>%
    .[,-1,with=F] %>%
    as.matrix() 

    psuedo.bulk = gse145281.clust@assays$RNA@counts %*% patient.cell.one.hot

    cells.1 = grep("_R", colnames(psuedo.bulk), value=T)
    cells.2 = grep("_NR", colnames(psuedo.bulk), value=T)
    deseq.out = DESeq2DETest(data.use=psuedo.bulk, cells.1=cells.2, cells.2=cells.1)
    deseq.dt = deseq.out %>%
    as.data.frame() %>%
    mutate(gene=rownames(.)) %>%
    data.table() 
    deseq.dt
}, error = function(e) NA)
})

names(deseq.all.out) = sort(unique(gse145281$seurat_clusters))
```


```{r}
# remove NA cluster data from deseq 
is.notincluded = names(deseq.all.out)[which(is.na(deseq.all.out))]
is.included = setdiff(names(deseq.all.out), is.notincluded)
samples.included = which(!(gse145281$seurat_clusters %in% is.notincluded))

psuedobulk.lfc = lapply(is.included, function(tt) deseq.all.out[[tt]]$log2FoldChange) %>%
do.call(cbind,.)
psuedobulk.lfc[is.na(psuedobulk.lfc)] = 0

gse145281.curr = gse145281[,samples.included]
meta.model4.dt = gse145281.curr@meta.data %>% 
data.table(ID=rownames(.)) %>%
.[,.(ID, response, patient=as.factor(patient), cluster=as.factor(seurat_clusters), 
    nCount_RNA = avinash::normalize.std(nCount_RNA),
     nFeature_RNA = avinash::normalize.std(nFeature_RNA))]
meta.model4.dt.curr = meta.model4.dt[,.(ID, cluster)]  %>%
mltools::one_hot(.) %>%
.[,-1,with=F] %>%
cbind(meta.model4.dt, .) 

library(lme4)
eval.lmer.psuedobulk.priors = function(dt.curr, val, fmla, psuedobulk.priors){
    tryCatch({
        val.res = lm(val ~ psuedobulk.priors) %>%
        stats::residuals()
    dt.curr = dt.curr %>%
    mutate(GENE=val.res)
    aa = lmer(data=dt.curr, fmla)
    preds = predict(aa, newdata=dt.curr)
    preds
}, error = function(e) NA
)
}
latent.var.names  = c(
    grep("cluster_", colnames(meta.model4.dt.curr), value=T),
     "nCount_RNA", "nFeature_RNA")
fmla <- as.formula(object = paste(
  "GENE ~",
  paste(latent.var.names[-1], collapse = "+"),
  "+(1|patient)"
  ))

eval.lmer.psuedobulk.priors2 = function(dt.curr, val, fmla, psuedobulk.priors){
    tryCatch({
    dt.curr = dt.curr %>%
    mutate(GENE=val) %>%
    mutate(psuedobulk.priors=psuedobulk.priors)
    aa = lmer(data=dt.curr, fmla)
    dt.curr$psuedobulk.priors = 0
    preds = predict(aa, newdata=dt.curr)
    preds
}, error = function(e) NA
)
}
latent.var.names  = c(
    grep("cluster_", colnames(meta.model4.dt.curr), value=T),
     "nCount_RNA", "nFeature_RNA", "psuedobulk.priors")
fmla <- as.formula(object = paste(
  "GENE ~",
  paste(latent.var.names[-1], collapse = "+"),
  "+(1|patient)"
  ))

genes.curr = gse145281.curr[["RNA"]]@var.features
exp.included.curr = gse145281.curr[["RNA"]][genes.curr,]
deseq.gene.order = deseq.all.out[[1]]$gene
nonresponders.inx = which(meta.model4.dt$response==0)
out.model4.models = mclapply(seq(nrow(exp.included.curr)), function(tt){ 
    gene.curr = rownames(exp.included.curr)[tt]
    psuedobulk.lfc.curr = psuedobulk.lfc[deseq.gene.order == gene.curr,]
    psuedobulk.lfc.matched =psuedobulk.lfc.curr[match(meta.model4.dt.curr$cluster,is.included)]
    psuedobulk.lfc.matched[nonresponders.inx] = 0

    eval.lmer.psuedobulk.priors2(meta.model4.dt.curr, exp.included.curr[tt,], fmla, psuedobulk.priors=psuedobulk.lfc.matched)
},
    mc.cores =16
    )


preds.patients.cluster = do.call(rbind, out.model4.models)

exp.curr.clust  = exp.curr[,meta.model4.dt.curr$cluster==2]
preds.patients.cluster.clust = preds.patients.cluster[,meta.model4.dt.curr$cluster==2]
response.clust = meta.model4.dt[cluster==2]$response
out.model4.final = mclapply(seq(nrow(exp.curr)), function(tt){
    tryCatch({
    aa = lm(exp.curr.clust[tt,]~ response.clust + preds.patients.cluster.clust[tt,])
    summary(aa)$coefficients["response.clust",]
}, error=function(e) NA)
},mc.cores =48
    )
out.model4.final.clust2 = do.call(rbind, out.model4.final) %>%
data.table() %>%
set_colnames(c("estimate","se", "t", "P")) %>%
mutate(p.adj=p.adjust(P))  %>%
mutate(gene=rownames(exp.curr)) %>%
data.table() %>%
.[order(P)]

markers.merge$model4=out.model4.final.clust2[match(markers.merge$genes,gene)]$estimate

library(ggpubr)
p = ggplot(markers.merge, aes(x=-model4,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model4 (R vs. NR)") + ylab("R3 vs. other-NR")
ggsave(file=".figs/gse145281.clust2.model4.pdf", p)

p = ggplot(markers.merge, aes(x=-model4,y=avg_logFC)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model4 (R vs. NR)") + ylab("Seurat (R vs. NR)")
ggsave(file=".figs/gse145281.clust2.model4.comparison.seurat.pdf", p)

genes.curr = out.model4.final.clust2$gene[1:16]
VlnPlot(gse145281.clust, genes.curr, group.by = 'patient') %>%
ggsave(file=".figs/gse145281.clust2.model4.vlnplot.pdf", ., width=15, height=10)

```


```{r}
# create psuedo.bulk expression 
sco.curr = gse145281[gse145281[["RNA"]]@var.features,gse145281$seurat_clusters ==2] 

exp.curr.clust  = sco.curr[["RNA"]]@data 
meta.dt.model5 = sco.curr@meta.data 
deseq.dt.model5 = deseq.all.out[[3]] %>%
.[match(rownames(sco.curr), gene)]
deseq.dt.model5[,factor:=ifelse(abs(stat) < 4.1, 0, 1 -3/abs(stat))]
deseq.factor.curr = deseq.dt.model5$factor

bulk.patient.order =  unique(meta.dt.model5$patient)
psuedobulk.exp.curr = lapply(bulk.patient.order,  function(tt) 
    rowMeans(exp.curr.clust[, meta.dt.model5$patient==tt],na.rm=T) ) %>% 
do.call(cbind, .)
psuedobulk.response = grepl("^R", bulk.patient.order) + 0

eval.lmer.psuedobulk.priors3 = function(dt.curr, val, psuedobulk.val, psuedobulk.response, deseq.factor){
    tryCatch({
    dt1 = data.table(psuedobulk.val=psuedobulk.val, psuedobulk.response=psuedobulk.response)
    m1 = lm(psuedobulk.val ~ psuedobulk.response, data=dt1)
    predicted = predict(m1, newdata=dt1) * deseq.factor
    predicted.matched = predicted[dt.curr$map]
    dt.curr = dt.curr %>%
    mutate(GENE=val) %>%
    mutate(GENE.res=val-predicted.matched) %>%
    mutate(preds.bulk=predicted.matched) 

    aa = lmer(data=dt.curr, GENE ~ 1|patient)
    dt.curr$preds.bulk = 0 
    preds = predict(aa, newdata=dt.curr)
    dt.curr = dt.curr %>%
    mutate(GENE=val) %>%
    mutate(preds=preds)
    aa = lm(GENE ~ response + preds, data = dt.curr)
    # bb = lm(GENE ~  preds, data = dt.curr)
    # anova(aa, bb)
    summary(aa)$coefficients["response",]
}, error = function(e) NA
)
}


meta.dt.model5$map = match(meta.dt.model5$patient, bulk.patient.order)

out.model5.models = mclapply(seq(nrow(exp.curr.clust)), function(tt){ 
    psuedobulk.val = psuedobulk.exp.curr[tt,]
    eval.lmer.psuedobulk.priors3(meta.dt.model5, exp.curr.clust[tt,], psuedobulk.val, psuedobulk.response=psuedobulk.response, deseq.factor.curr[tt])

},
mc.cores =48
)

out.model5.final.clust2 = do.call(rbind, out.model5.models) %>%
data.table() %>%
set_colnames(c("estimate","se", "t", "P")) %>%
mutate(p.adj=p.adjust(P))  %>%
mutate(gene=rownames(exp.curr.clust)) %>%
data.table() %>%
.[order(P)]

EnhancedVolcano::EnhancedVolcano(deseq.dt.model5,
                             lab =  deseq.dt.model5$gene,
                             x = 'log2FoldChange',
                             y = 'pvalue',
                             pCutoff = 5E-4,
                             FCcutoff = 1,
                             # ylim = c(0,5.2),
                             # xlim = c(-1, 1),
                             # pointSize = 4.0,
                             pointSize = c(ifelse(deseq.dt.model5$pvalue< 1E-2, 1, 0.2)),
                             labSize = 4.0,
                             legend=c('NS','Log (base 2) fold-change','P value',
                                      'P value & Log (base 2) fold-change'),
                             legendPosition = 'right',
                             legendLabSize = 8,
                             legendIconSize = 4.0,
                             drawConnectors = TRUE,
                             widthConnectors = 0.2,
                             colAlpha = 0.8,
                             colConnectors = 'grey30'
) %>%
ggsave(".figs/gse145281.clust2.volcano.deseq.pdf", .)




eval.lmer.psuedobulk.priors4 = function(dt.curr, val, psuedobulk.val, psuedobulk.response, deseq.factor){
    tryCatch({
    dt1 = data.table(psuedobulk.val=psuedobulk.val, psuedobulk.response=psuedobulk.response)
    m1 = lm(psuedobulk.val ~ psuedobulk.response, data=dt1)
    predicted = predict(m1, newdata=dt1) * deseq.factor
    predicted.matched = predicted[dt.curr$map]
    dt.curr = dt.curr %>%
    mutate(GENE=val) %>%
    mutate(GENE.res=val-predicted.matched) %>%
    mutate(preds.bulk=predicted.matched) 

    aa = lmer(data=dt.curr, GENE.res ~ 1|patient)
    dt.curr$preds.bulk = 0 
    preds = predict(aa, newdata=dt.curr)
    dt.curr = dt.curr %>%
    mutate(GENE=val) %>%
    mutate(preds=preds)
    aa = lm(GENE ~ response + preds, data = dt.curr)
    # bb = lm(GENE ~  preds, data = dt.curr)
    # anova(aa, bb)
    summary(aa)$coefficients["response",]
}, error = function(e) NA
)
}


out.model6.models = mclapply(seq(nrow(exp.curr.clust)), function(tt){ 
    psuedobulk.val = psuedobulk.exp.curr[tt,]
    eval.lmer.psuedobulk.priors4(meta.dt.model5, exp.curr.clust[tt,], psuedobulk.val, psuedobulk.response=psuedobulk.response, deseq.factor.curr[tt])

},
mc.cores =48
)

out.model6.final.clust2 = do.call(rbind, out.model6.models) %>%
data.table() %>%
set_colnames(c("estimate","se", "t", "P")) %>%
mutate(p.adj=p.adjust(P))  %>%
mutate(gene=rownames(sco.curr)) %>%
data.table() %>%
.[order(P)]

EnhancedVolcano::EnhancedVolcano(out.model6.final.clust2,
                             lab = out.model6.final.clust2$gene,
                             x = 'estimate',
                             y = 'P',
                             pCutoff = 1e-2,
                             FCcutoff = .08,
                             # ylim = c(0,5.2),
                             # xlim = c(-1, 1),
                             # pointSize = 4.0,
                             pointSize = c(ifelse(out.model6.final.clust2$P< 1E-2, 2, 0.2)),
                             labSize = 4.0,
                             legend=c('NS','Log (base 2) fold-change','P value',
                                      'P value & Log (base 2) fold-change'),
                             legendPosition = 'right',
                             legendLabSize = 8,
                             legendIconSize = 3.0,
                             drawConnectors = TRUE,
                             widthConnectors = 0.2,
                             colAlpha = 0.8,
                             colConnectors = 'grey30'
) %>%
ggsave(".figs/gse145281.clust2.volcano.model6.pdf", .)

genes.curr = out.model6.final.clust2[P<1E-2]$gene
VlnPlot(sco.curr, genes.curr, group.by = 'patient') %>%
ggsave(file=".figs/gse145281.clust2.model6.vlnplot.pdf", ., width=15, height=10)

markers.merge$model6=out.model6.final.clust2[match(markers.merge$genes,gene)]$estimate

library(ggpubr)
p = ggplot(markers.merge, aes(x=-model6,y=avg_logFC.r3)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "pearson") +
xlab("model6 (R vs. NR)") + ylab("R3 vs. other-R")
ggsave(file=".figs/gse145281.clust2.model6.pdf", p)

p = ggplot(markers.merge, aes(x=-model6,y=-avg_logFC)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "pearson") +
xlab("model6 (R vs. NR)") + ylab("Seurat (R vs. NR)")
ggsave(file=".figs/gse145281.clust2.model6.comparison.seurat.pdf", p)



EnhancedVolcano::EnhancedVolcano(,
                             lab = out.model6.final.clust2$gene,
                             x = 'estimate',
                             y = 'P',
                             pCutoff = 1e-2,
                             FCcutoff = .08,
                             # ylim = c(0,5.2),
                             # xlim = c(-1, 1),
                             # pointSize = 4.0,
                             pointSize = c(ifelse(out.model6.final.clust2$P< 1E-2, 2, 0.2)),
                             labSize = 4.0,
                             legend=c('NS','Log (base 2) fold-change','P value',
                                      'P value & Log (base 2) fold-change'),
                             legendPosition = 'right',
                             legendLabSize = 8,
                             legendIconSize = 3.0,
                             drawConnectors = TRUE,
                             widthConnectors = 0.2,
                             colAlpha = 0.8,
                             colConnectors = 'grey30'
) %>%
ggsave(".figs/gse145281.clust2.volcano.model6.pdf", .)


sco.curr.confound = sco.curr[, (sco.curr$seurat_clusters==2 & sco.curr$response==0)]

for (pat in unique(sco.curr.confound$patient)){ 
    label = sprintf("%s_confound", pat) 
    aa <- FindMarkers(sco.curr.confound, ident.1 = pat, group.by = 'patient', min.pct = -1, logfc.threshold = -1)
markers.merge[[label]] = aa[markers.merge$gene,]$avg_logFC
}
save(file="~/liulab_home/data/single_cell/GSE145281/GSE145281.RData", gse145281)

sco.curr.confound = sco.curr[, (sco.curr$seurat_clusters==2 & sco.curr$response==1)]
for (pat in unique(sco.curr.confound$patient)){ 
    label = sprintf("%s_confound", pat) 
    aa <- FindMarkers(sco.curr.confound, ident.1 = pat, group.by = 'patient', min.pct = -1, logfc.threshold = -1)
markers.merge[[label]] = aa[markers.merge$gene,]$avg_logFC
}

library(ggpubr)
avi.dt = data.table(x=markers.merge$avg_logFC, y=unlist(markers.merge[,grep("confound", colnames(markers.merge)), with=F]), patient=rep(c(paste0("NR",1:5), paste0("R",1:5)), each=2000))
p = ggplot(avi.dt, aes(x=x,y=y)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("model1 (R vs. NR)") + ylab("NR vs. other-NR / R vs. other-R") + facet_wrap(~patient)

ggsave(file=".figs/gse145281.seurat.clust2.seurat.pdf", p)


avi.dt = data.table(x=markers.merge$model6, y=unlist(markers.merge[,grep("confound", colnames(markers.merge)), with=F]), patient=rep(c(paste0("NR",1:5), paste0("R",1:5)), each=2000))
p = ggplot(avi.dt, aes(x=x,y=y)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "pearson") +
xlab("model6 (R vs. NR)") + ylab("NR vs. other-NR / R vs. other-R") + facet_wrap(~patient)

ggsave(file=".figs/gse145281.clust2.model6.all.pdf", p)

```

## Check if patient-specific effects are same across clusters

```{r}

sco.nonresponse = gse145281[gse145281[["RNA"]]@var.features,(gse145281$response ==0)] 
patient.effects.clust = list()
for (clust in seq(0,5)) {
sco.curr = sco.nonresponse[,(sco.nonresponse$seurat_clusters==clust)]
patient.curr = sco.curr$patient
genes.exp.curr =  as.matrix(sco.curr[["RNA"]]@data)
patient.effects.clust[[clust+1]]  = mclapply(seq(nrow(genes.exp.curr)), 
    function(tt) {
        tryCatch(
        {
            dt1 = data.table( 
            GENE = genes.exp.curr[tt,], 
            patient= patient.curr)
            aa = lmer(GENE~(1|patient), data=dt1)
            unlist(coef(aa)$patient) %>%
            set_names(NULL)
        }, error = function(e) rep(NA,5)
        )

    },
    mc.cores =48
    ) %>% 
do.call(rbind, .)
} 

avi.dt = data.table(
    clust1=patient.effects.clust[[1]][,1],
    clust2=patient.effects.clust[[2]][,1]
    )
library(ggpubr)
p = ggplot(avi.dt, aes(x=clust1,y=clust2)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("Patient specific effect (clust0) ") + ylab("Patient specific effect (clust1)")
ggsave(file=".figs/gse145281.patient.specific.effects.clust0_1.pdf", p)



avi.dt = data.table(
    clust1=patient.effects.clust[[1]][,1],
    clust2=patient.effects.clust[[3]][,1]
    )
library(ggpubr)
p = ggplot(avi.dt, aes(x=clust1,y=clust2)) + 
geom_point() + geom_smooth(method="lm") + stat_cor(method = "spearman") +
xlab("Patient specific effect (clust0) ") + ylab("Patient specific effect (clust2)")
ggsave(file=".figs/gse145281.patient.specific.effects.clust0_2.pdf", p)

```

## Analysis of LEE data. 
#at location ~/liulab_home/data/scRNA/Lee_data
# could not be downloaded "Pool84_11" "Pool87_37" "Pool87_40" "Pool87_47"

scp -r  Pool84_11/filtered_feature_bc_matrix $BCB:~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/GEXdata/Pool84_11/.
scp -r  Pool87_37/filtered_feature_bc_matrix $BCB:~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/GEXdata/Pool87_37/.
scp -r  Pool87_40/filtered_feature_bc_matrix $BCB:~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/GEXdata/Pool87_40/.
scp -r  Pool87_47/filtered_feature_bc_matrix $BCB:~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/GEXdata/Pool87_47/.

```{r}

files = list.files(path="~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/GEXdata", recursive=T, pattern="mtx.gz", full.names=T)
# library(magrittr)
# file.local = strsplit(files, split="\\/") %>% 
# sapply(., function(tt) tt[1]) %>% 
# data.table(V1=sort(.),seq(length(files)))

# file.lynx = strsplit(files, split="\\/") %>% 
# sapply(., function(tt) tt[1]) %>% 
# data.table(V1=sort(.),seq(length(files)))

library(Matrix)
lee.exp.list = mclapply(files, function(fid)
 {
    dir.curr = dirname(fid)
    gene.name = fread(paste0(dir.curr, "/features.tsv.gz"), header=F)
    pool.id = strsplit(fid, split="\\/")[[1]]
    pool.id = pool.id[length(pool.id)-2]
    mat = tryCatch( 
        {
            fid %>%
     gzfile(., "rb") %>% gzcon () %>%
    readMM() %>% 
    set_rownames(gene.name$V2)
    },  error = function(e) NA) 
    closeAllConnections()
    # lee.exp.list[[pool.id]] <- mat
    # barcode = fread(paste0(dir.curr, "/barcodes.tsv.gz"), header = F)
    list(pool.id, mat)
}, mc.cores=32)

lee.dims = sapply(lee.exp.list, function(tt) tt[[2]] %>% dim()) 
sel = !sapply(lee.dims, is.null)
# create data matrix and running HIPPO
options(error=recover)
lee.exp = lee.exp.list[sel] %>%
lapply(., function(tt) tt[[2]]) %>%
do.call(cbind, .)
# lee.exp.list = lee.exp.list[!is.na(lee.exp.list)]
meta.data = lapply(lee.exp.list[sel], function(tt){ 
    data.table(cell.name=paste(tt[[1]], seq(ncol(tt[[2]])), sep="."), poolid=tt[[1]])
}) %>% do.call(rbind, .)
meta.data[,poolid:=toupper(poolid)]

meta1=readxl::read_excel("~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/scRNA-seq QC/BMS205 HL samples ssRNA seq  .xlsx", sheet=1)
meta1 = meta1 %>%
set_colnames(gsub(pattern = " ", colnames(meta1), replacement=".")) %>%
data.table() %>%
setnames(., 2, "response")%>%
.[,patient.name:=toupper(PBMC.Sample.ID)] 



meta2=readxl::read_excel("~/liulab_home/data/single_cell/Lee_data/Lee_SequencingData/scRNA-seq QC/BMS205 HL samples ssRNA seq  .xlsx", sheet=2, skip=1)
meta2 = as.data.table(meta2[,1:4]) %>% 
setnames(.,4, "poolid") %>%
.[,poolid:=toupper(poolid)] %>%
.[,patient.name:=toupper(sapply(ID, function(tt) strsplit(tt,split=" ")[[1]][1]))] %>%
.[,CD3.status:=toupper(sapply(ID, function(tt) strsplit(tt,split=" ")[[1]][2]))]


meta12 = merge(meta2, meta1, by="patient.name", suffixes=c("", ".y"))
lee.meta.data = cbind(cell.name=meta.data[["cell.name"]], meta12[match(meta.data$poolid, poolid)]) 

lee.meta.data = lee.meta.data %>% 
DataFrame() %>%
set_rownames(lee.meta.data$cell.name)

library(SingleCellExperiment)
# devtools::install_github("tk382/HIPPO", build_vignettes = TRUE)
source("~/liulab_home/softwares/HIPPO/R/hippo.R")
set.seed(20191031)
lee.sce = SingleCellExperiment(assays = list(counts = lee.exp), colData=lee.meta.data)
saveRDS(lee.sce, file="~/liulab_home/data/single_cell/Lee_data/lee.sce.RDS")
# save(file="~/liulab_home/data/single_cell/Lee_data/lee.exp.list.RData", lee.exp.list)
lee.cd3 = lee.sce[,lee.sce@colData$CD3.status=="CD3+"]
rm(lee.exp.list, lee.exp, lee.sce)
gc()
set.seed(1000)
library(Matrix)
rand.samp = sample(ncol(lee.cd3), 30000)
lee.small = lee.cd3[,sort(rand.samp)]
lee.small = hippo(lee.small, 
            K = 10, 
            z_threshold = 2, 
            outlier_proportion = 0.005,
            verbose=TRUE)
library(umap)
library(ggplot2)
lee.small = myhippo_dimension_reduction(lee.small, method="umap", pca=50, distance=cosine)
p = hippo_umap_plot(lee.small, k = 1:10)
ggsave(p, file=".figs/lee.small.hippo.pdf")

library(data.table)
temp = lee.small@int_metadata$hippo$umap %>% data.table()
avi.dt =  temp[K==8] %>% 
cbind(.,lee.small@colData) %>% as.data.table() %>%
.[,patient.name:=as.factor(patient.name)]
p = ggplot(avi.dt, aes(x=umap1, y=umap2)) + 
geom_point(aes(color=label)) +  theme_bw() + 
facet_wrap(~patient.name) 
ggsave(p, file=".figs/lee.small.patient.pdf")
avi.dt[,responseORnormal:=ifelse(Cohort=="Healthy donors", Cohort, response)]
avi.dt[,responseAndtreatment:=paste(responseORnormal, Treatment.Cycle)]
p= ggplot(avi.dt[!(Cohort %in% c("New"))], aes(x=umap1, y=umap2)) + 
geom_point(aes(color=label)) +  theme_bw() + 
facet_wrap(~responseAndtreatment)
ggsave(p, file=".figs/lee.small.response.treatment.pdf")

```
