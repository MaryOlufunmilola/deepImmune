---
title: "Cell type specific runs"
output: html_notebook
---


```{r}
library(data.table)
source("/homes6/asahu/project/deeplearning/icb/deepImmune/source.R")
cwd= "/homes6/asahu/project/deeplearning/icb/data/tcga/scrna.v4.genes/tensorboardLog/nopipeline_vae_20190819-161104/epoch-142/"
dir.create(cwd)
    
# system(sprintf("cp /homes6/asa/hu/project/deeplearning/icb//data/Getz_scRNA/scrna.v4.genes/val_prediction.csv %s", cwd))
dataset.sample.name = fread("/homes6/asahu/project/deeplearning/icb/data/Getz_scRNA//scrna.v4.genes/samples_name.txt")$x
icb.phenotype= fread(sprintf("%s/val_prediction.csv", cwd))
icb.phenotype = icb.phenotype[unlist(icb.phenotype$sample_name) +1]
## correct the headers 
header = fread("/homes6/asahu/project/deeplearning/icb/data/tcga/scrna.v4.genes/tensorboardLog/nopipeline_vae_20190819-161104/best_val_0.csv",nrows = 1)
colnames(icb.phenotype) = colnames(header)
icb.phenotype.col.dt = data.table(colnames(icb.phenotype), seq(ncol(icb.phenotype))) 
```


```{r}
load("~/project/deeplearning/icb/data/Getz_scRNA/phenotype_sel.mod.RData")
resp = fread("/liulab/asahu/data/ssgsea/xiaoman/getz/GSE120575_patient_ID_single_cells.txt", skip=19)
xx = paste0("V",1:35)
colnames(resp)[1:35] = xx
resp$V2 = gsub(resp$V2, pattern="-", replacement=".")
# resp.patient
resp.matched=resp[match(phenotype_sel.mod$sample.name, resp$V2)]
response = resp.matched$V6
response.bin = ifelse(response=="Responder", 1, 0)

library(pROC)
cell.types = unique((phenotype_sel.mod$assign.ident.2) )
pre_post = resp$V5
pretreatment.samples = grep(pre_post, pattern="^Pre")
posttreatment.samples = grep(pre_post, pattern="^Post")
```

```{r}
load("~/project/deeplearning/icb/data/Getz_scRNA/dataset_ssgsea_temp.RData")
load("~/project/deeplearning/icb/data/Getz_scRNA/headers.RData")
icb.expression = t(dataset_ssgsea_temp[,2:16292, with=F])
colnames(icb.expression) =  dataset_ssgsea_temp$gene_name
rownames(icb.expression) =  gsub(unlist(headers[1])[-1], pattern="-", replacement=".")
phenotype_sel.mod$sample.name = gsub(phenotype_sel.mod$sample.name, pattern="-", replacement=".")
length(intersect(rownames(icb.expression), phenotype_sel.mod$sample.name))
icb.expression.matched = icb.expression[match(phenotype_sel.mod$sample.name, rownames(icb.expression)),]
icb.expression.matched = icb.expression[match(phenotype_sel.mod$sample.name, rownames(icb.expression)),]
identical(phenotype_sel.mod$sample.name, dataset.sample.name)
rm(dataset_ssgsea_temp, icb.expression)
```


## Plot aucs, and association of immune factors with embeddings

```{r}
source("~/project/deeplearning/icb/deepImmune/data_processing/ssgsea/imputation/scRNA/epoch-142/source.proj.R")
# system(sprintf("cp /homes6/asahu/project/deeplearning/icb/data/tcga/scrna.v4.genes/val_prediction.csv %s/tcga_val_prediction.csv", cwd))
library(Hmisc)
tcga.phenotype = fread(sprintf("%s/tcga_val_prediction.csv", cwd))
tcga.dataset = fread("~/project/deeplearning/icb/data/tcga/scrna.v4.genes/dataset.txt")
tcga.phenotype = tcga.phenotype[unlist(tcga.phenotype$sample_name) +1]
col.pheno = colnames(tcga.phenotype)
embedding.inx = grep(colnames(icb.phenotype), pattern = "embedding", value = T)

pheno.inx.start = icb.phenotype.col.dt[V1=="B_cells_naive.output"]$V2
pheno.inx.end = tail(grep(icb.phenotype.col.dt$V1, pattern="output$"),1)
indexes.output = colnames(icb.phenotype)[pheno.inx.start:pheno.inx.end]
survival.inx.start = icb.phenotype.col.dt[V1=="OS.time.output"]$V2
indexes.survival = colnames(icb.phenotype)[seq(survival.inx.start, survival.inx.start+3)]
selected.outputs = indexes = c( embedding.inx, indexes.output, indexes.survival)
```


```{r}
##
xx= plot.all.aucs(cwd)
if.indexes = c(indexes.survival,indexes.output)
if.indexes.inp = colnames(icb.phenotype)[339:473]
input.genes = colnames(icb.phenotype)[10:338]
xx = plot.embedding.immunefactor.association(cwd, if.indexes = if.indexes, filename = "embedding_if_output.pdf")
xx = plot.embedding.immunefactor.association(cwd, if.indexes = if.indexes.inp, filename = "embedding_if_input.pdf")
xx = plot.embedding.immunefactor.association(cwd, if.indexes = input.genes, filename = "embedding_input.genes.pdf")
```



```{r}
cell.type.curr = "All_T_Cells.v2"
cell.type.curr.list = c("Cytotoxicity CD8T", "Exhausted CD8T", "Exhausted/Cellcytle T", "Exhausted/HS CD8T", "CD4Tmactive", "RegulatoryTcell", "RestingmemoryCD4Tcell")
cell.cwd = sprintf("%s/%s", cwd, cell.type.curr)
dir.create(cell.cwd)
```



## Cell type  clustering

```{r}
library(avinash)
library(ggplot2)

tsne.dir = sprintf("%s/tsnes",cell.cwd)
dir.create(tsne.dir)
output.inx=grep(pattern = ".output",colnames(icb.phenotype), value=T)
embedding.inx=grep(pattern = "embedding",colnames(icb.phenotype), value = T)
d1=icb.phenotype[,c(embedding.inx, output.inx),with=F]
d2 = resp.matched[,.(V2, V5, V6,V7)]
setnames(d2, 1:4,c("sample.name", "patient.name", "response", "treatment"))
d3 = phenotype_sel.mod[,.(assign.ident.2)]
data_tsne.merge = as.data.frame(cbind(d3, d2, d1))
# data_tsne.merge[,embedding.inx]

cell.type.inx=which(data_tsne.merge$assign.ident.2 %in% cell.type.curr.list)
data.curr = data_tsne.merge[cell.type.inx,]
# all.p = plotSNE(data = data.curr , col=embedding.inx, size = 2,do.discrete=F, title= sprintf("%s %s", cell.type.curr, "response"),
#                 color.col = "response", perplexity = 30, theta = 0, pca=TRUE,
#                 filename=sprintf("%s/%s_%s_final.pdf", tsne.dir, cell.type.curr, "response"), max_iter=1000)

if(T){
umap.param.dir = sprintf("%s/umap.param/", tsne.dir)

dir.create(umap.param.dir, recursive = T)
N_neighbors = c(5, 10, 15, 20, 40)
learning_rates = c(10, 1, .1, .01)
min_dists = c(.1, .01, .001)
pcas = list(NULL, 10)

require(doMC)
require(foreach)
registerDoMC(cores = 32)

foreach(n_neighbors= N_neighbors) %dopar%{
    foreach(learning_rate = learning_rates) %dopar% {
        foreach(min_dist= min_dists) %dopar%{
            for (pca in pcas) {
                
set.seed(1232)
                pca.str = ifelse(is.null(pca), 0, pca)
                temp = plotUMAP(data = data.curr, col=embedding.inx, size=1.5, do.discrete=F, title= sprintf("%s %s", cell.type.curr, "response"),
                                color.col = as.factor(data.curr$response), 
                                n_neighbors = n_neighbors, learning_rate = learning_rate, min_dist = min_dist, pca=pca,
                                filename=sprintf("%s/%s_%s_umap_%s_%s_%s_%s.pdf", umap.param.dir, cell.type.curr, "response",  n_neighbors,  learning_rate,min_dist, pca.str))
            }
        }
    }
}
}

set.seed(1232)
# n_neighbors =40; learning_rate =10; min_dist = 0.01;pca = NULL
n_neighbors =40; learning_rate =.1; min_dist = 0.001; pca = NULL

umap.all.p = plotUMAP(data = data.curr, col=c(embedding.inx), size=1.5, do.discrete=F, 
                                n_neighbors = n_neighbors, learning_rate = learning_rate, min_dist = min_dist, pca=pca,
                      title= sprintf("%s %s", cell.type.curr, "response"),
                      color.col = as.factor(data.curr$response), 
                      filename=sprintf("%s/%s_%s_umap.pdf", tsne.dir, cell.type.curr, "response"), n_epochs = 500, metric = "euclidean")


print(umap.all.p[[2]])
```


## plot all genes UMAP 
```{r}

n_neighbors =15; learning_rate =.01; min_dist = 0.1; pca = 10
icb.expression.curr = icb.expression.matched[data.curr$sample.name,]
data.curr.temp = cbind(data.curr, icb.expression.curr)

umap.gene.p = plotUMAP(data = data.curr.temp, col = colnames(icb.expression.curr), size=1.5, do.discrete=F, 
                                n_neighbors = n_neighbors, learning_rate = learning_rate, min_dist = min_dist, pca=pca,
                      title= sprintf("%s %s", cell.type.curr, "response"),
                      color.col = "response", 
                      filename=sprintf("%s/%s_%s_umap_allgenes.pdf", tsne.dir, cell.type.curr, "response"), n_epochs = 500, metric = "euclidean")

p.umap <- plot_grid(umap.gene.p[[2]], umap.all.p[[2]])
```




```{r}
data.curr$shape = data.curr$response
data.curr$umap1 = umap.all.p[[1]]$embedding[,1]
data.curr$umap2 = umap.all.p[[1]]$embedding[,2]
data.curr$patient.name.small=gsub("Pre_P", gsub("Post_P", data.curr$patient.name, replacement = "O"), replacement = "")
# data.curr[,patient:=]
xx = text.clusters.features(data=data.curr, cluster=data.curr[,c("umap1", "umap2")],  text.cols = "patient.name.small",
                              title="patient",size=1, filename=sprintf("%s/patient", tsne.dir), normalize=F, do.discrete=T)
tt = xx$patient.name.small + theme(legend.position = "none")
print(tt)
# data.curr$shape = data.curr$response
# data.curr$umap1 = umap.gene.p[[1]]$embedding[,1]
# data.curr$umap2 = umap.gene.p[[1]]$embedding[,2]
# data.curr$patient.name.small=gsub("Pre_P", gsub("Post_P", data.curr$patient.name, replacement = "O"), replacement = "")
# # data.curr[,patient:=]
# xx_gene = text.clusters.features(data=data.curr, cluster=data.curr[,c("umap1", "umap2")],  text.cols = "patient.name.small",
#                               title="patient",size=1, filename=sprintf("%s/patient_gene", tsne.dir), normalize=F, do.discrete=T)

 # table(data.curr[data.curr$umap1< -4.5,]$patient.name.small)
```


```{r}
# data.curr$shape = data.curr$response
# data.curr$umap1 = umap.all.p[[1]]$embedding[,1]
# data.curr$umap2 = umap.all.p[[1]]$embedding[,2]
# xx = text.clusters.features(data=data.curr, cluster=data.curr[,c("umap1", "umap2")],  color.cols = "assign.ident.2",
#                               title="patient",size=2, filename=sprintf("%s/patient", tsne.dir), normalize=F, do.discrete=T)

```

## check where are categories of Moshe et. al. lies :
```{r}
xx_identify = text.clusters.features(data=data.curr, cluster=data.curr[,c("umap1", "umap2")],  text.cols = "assign.ident.2",
                              title="assign_ident_2",size=1, filename=sprintf("%s/assign.ident.2", tsne.dir), normalize=F, do.discrete=T)

print(xx_identify)
```

## Expression of TRA,B,D,G
```{r}
save.dir = sprintf("%s/UMAP/", cell.cwd)
dir.create(save.dir, recursive = T)
 grep("TRGV", colnames(icb.expression.matched), value=T)
types = c("TRAV", "TRBV", "TRDV", "TRGV")

trv.inx =  unique (grep(paste(types,collapse="|"), 
                        colnames(icb.expression.matched))

data.all = as.data.frame(log(icb.expression.matched[cell.type.inx,c("RAG1", "RAG2")]+1))
xx = color.clusters.features( data=data.all, cluster=as.data.table(data.curr)[,.(umap1, umap2)],  color.cols = colnames(data.all),
                              title="",size=2, filename=sprintf("%s/gene_", save.dir), normalize=F, do.discrete=F)


 trv.exp = list()
     for(type in types)
                  trv.exp[[type]] = rowSums(icb.expression.matched[, grep(type, colnames(icb.expression.matched))])
trv.exp = do.call(cbind, trv.exp)

data.all = as.data.frame(trv.exp[cell.type.inx,])
xx = color.clusters.features( data=data.all, cluster=as.data.table(data.curr)[,.(umap1, umap2)],  color.cols = colnames(data.all),
                              title="",size=2, filename=sprintf("%s/gene_", save.dir), normalize=F, do.discrete=F)



# library(cowplot)
# p <- plot_grid(plotlist = xx, nrow=2)
# print(xx)

colnames(icb.expression.matched))])
trv.exp = do.call(cbind, trv.exp)

data.all = as.data.frame(log(icb.expression.matched[cell.type.inx,c("RAG1", "RAG2")]+1))
xx = color.clusters.features( data=data.all, cluster=as.data.table(data.curr)[,.(umap1, umap2)],  color.cols = colnames(data.all),
                              title="",size=2, filename=sprintf("%s/gene_", save.dir), normalize=F, do.discrete=F)



```

## Cluster based on tsne
```{r}
# library(scater)
# filename = sprintf("%s/%s_%s_umap_clustering.pdf", tsne.dir, cell.type.curr, "response")
# 
# data.tsne= as.data.frame(all.p[[1]]$Y)
# data.exp = t(icb.expression.matched)
# # # Defining clusters and markers:
# library(scran)
# data.DI = data_tsne.merge[locx,58:121]
# # data.DI = data.tsne
# snn.gr <- buildSNNGraph(t(data.DI))
# data.tsne$clust1 = factor(igraph::cluster_walktrap(snn.gr)$membership)
# data.tsne.dt = data.table(data.tsne)
# data.summ = data.tsne.dt[,.(clust.m=median(V2)),by=clust1]
# data.summ = data.summ[order(clust.m)]
# data.summ$clust = seq(nrow(data.summ))
# data.tsne$clust = as.factor(data.summ[match(data.tsne$clust1, clust1)]$clust)
# data.tsne$cell_name = colnames(data.exp)[locx]
# p=ggplot(data.tsne, aes(x=V1, y=V2)) +
#     geom_point(size=2,aes(color=clust), alpha=0.8) +
#     guides(colour=guide_legend(override.aes=list(size=4))) +
#     xlab("Dim1") + ylab("Dim2") +
#     # ggtitle(label = title) +
#     theme_light(base_size=20) +
#     theme(axis.text.x=element_blank(),
#           axis.text.y=element_blank()) 
# # if(!is.null(filename)) ggsave(file=filename, p)
# 
# print(p)
# ggsave(file=filename, p)


```

## Cluster based on umap
```{r}
library(scater)
filename = sprintf("%s/%s_%s_tsne_clustering.pdf", tsne.dir, cell.type.curr, "response")

data.tsne= as.data.frame(umap.all.p[[1]]$embedding)
# colnames(data.tsne) =c("UMAP1", "UMAP2")
data.curr$UMAP1 = data.tsne$V1
data.curr$UMAP2 = data.tsne$V2
data.curr = data.table(data.curr)
# data.curr = data.curr[match(rownames(icb.expression.matched), sample.name)]
# # Defining clusters and markers:
library(scran)
embedding.mat  = data.curr[,.SD, .SDcols=names(data.curr) %like% "^embedding"]
embedding.mat  = data.curr[,.SD, .SDcols=names(data.curr) %like% "^UMAP"]
data.DI = embedding.mat 
# data.DI = data.curr[[grep("^embedding", names(data.curr))]]
snn.gr <- buildSNNGraph(t(data.DI), k=1000, d =5)
cluster1.igraph = factor(igraph::cluster_walktrap(snn.gr, steps = 10)$membership)
data.curr[,response.bin:=ifelse(response=="Responder",1,0)] 
data.summ = data.curr[,.(clust.m=mean(response.bin)),by=cluster1.igraph]
data.summ = data.summ[order(clust.m)]
data.summ$clust = seq(nrow(data.summ))
match.inx = match(cluster1.igraph, data.summ$cluster1.igraph)
data.curr$cluster = as.factor(data.summ[match.inx]$clust)
p=ggplot(data.curr, aes(x=UMAP1, y=UMAP2)) +
    geom_point(size=2,aes(color=cluster), alpha=0.8) +
    guides(colour=guide_legend(override.aes=list(size=4))) +
    xlab("Dim1") + ylab("Dim2") +
    # ggtitle(label = title) +
    theme_light(base_size=20) +
    scale_color_tableau() + 
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
# if(!is.null(filename)) ggsave(file=filename, p)

print(p)
ggsave(file=filename, p)

```

## Kmeans
```{r}
set.seed(100)
data.curr[,UMAP1:=umap1]
data.curr[,UMAP2:=umap2]

embedding.mat  = data.curr[,.SD, .SDcols=names(data.curr) %like% "^UMAP"]
data.DI = embedding.mat 
clust.kmeans <- kmeans(data.DI, centers=7, nstart = 25)
table(clust.kmeans$cluster)

data.curr$cluster1 = (clust.kmeans$cluster)
data.curr[,cluster:= as.factor(cluster1)]
p=ggplot(data.curr, aes(x=UMAP1, y=UMAP2)) +
    geom_point(size=2,aes(color=cluster), alpha=0.8) +
    guides(colour=guide_legend(override.aes=list(size=4))) +
    xlab("Dim1") + ylab("Dim2") +
    # ggtitle(label = title) +
    theme_light(base_size=20) +
    scale_color_tableau() + 
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
# if(!is.null(filename)) ggsave(file=filename, p)

print(p)
filename = sprintf("%s/%s_%s_kmean_clustering.pdf", tsne.dir, cell.type.curr, "response")
ggsave(file=filename, p)
```


## Kmeans
```{r}
set.seed(100)
data.curr[,UMAP1:=umap1]
data.curr[,UMAP2:=umap2]
xx = data.curr[UMAP2< -2.5 & UMAP1 < -1][,.(mean(UMAP1), mean(UMAP2))]
centers = t(cbind(t(xx), 
                c(-5, 0), 
                c(0, 2.5), 
                c(2.5, 4),
                c(4,1)
            
                ))
embedding.mat  = data.curr[,.SD, .SDcols=names(data.curr) %like% "^UMAP"]
data.DI = embedding.mat 
clust.kmeans <- kmeans(data.DI, centers=4, nstart = 25)
table(clust.kmeans$cluster)

data.curr$cluster1 = (clust.kmeans$cluster)
data.curr[,cluster:=  ifelse(UMAP2< -2.5 & UMAP1 < -1, 5, cluster1)]
data.curr[,cluster:= as.factor(cluster)]
p=ggplot(data.curr, aes(x=UMAP1, y=UMAP2)) +
    geom_point(size=2,aes(color=cluster), alpha=0.8) +
    guides(colour=guide_legend(override.aes=list(size=4))) +
    xlab("Dim1") + ylab("Dim2") +
    # ggtitle(label = title) +
    theme_light(base_size=20) +
    scale_color_tableau() + 
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
# if(!is.null(filename)) ggsave(file=filename, p)

print(p)
filename = sprintf("%s/%s_%s_kmean_clustering.pdf", tsne.dir, cell.type.curr, "response")
ggsave(file=filename, p)
```

## Cell cycle analysis

```{r}
cell.cycle = fread("/liulab/asahu/data/ssgsea/xiaoman/getz/Gad_cell_cycle_score.csv")
data.curr$cell.cycle = as.factor(cell.cycle[match(data.curr$sample.name, V1)]$Phase)
data.curr$G2M.Score = cell.cycle[match(data.curr$sample.name, V1)]$G2M.Score
data.curr$S.Score = cell.cycle[match(data.curr$sample.name, V1)]$S.Score
cell.cycle.monocyte = cell.cycle[match(data.tsne$sample.name, V1)]
p=ggplot(data.curr, aes(x=UMAP1, y=UMAP2)) +
    geom_point(size=1,aes(color=cell.cycle), alpha=0.7) +
    guides(colour=guide_legend(override.aes=list(size=4))) +
    xlab("Dim1") + ylab("Dim2") +
    # ggtitle(label = title) +
    theme_light(base_size=20) +
    scale_color_tableau() + 
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
# if(!is.null(filename)) ggsave(file=filename, p)
print(p)
ggsave(sprintf("%s/umap_clustering_cell_cycle.pdf", tsne.dir),p)

# cell.cycle.monocyte = cell.cycle[match(data.tsne$sample.name, V1)]
# cell.cycle.monocyte$clust = data.tsne$clust
# p=ggplot(cell.cycle.monocyte, aes(x=S.Score, y=G2M.Score)) +
#   geom_point(size=2,aes(color=cluster), alpha=0.8) +
#   guides(colour=guide_legend(override.aes=list(size=4))) +
#   # xlab("Dim1") + ylab("Dim2") +
#   # ggtitle(label = title) +
#   theme_light(base_size=20) +
#   theme(axis.text.x=element_blank(),
#         axis.text.y=element_blank()) 
# ggsave(sprintf("%s/umap_clustering_lustering_cell_cycle.pdf", tsne.dir),p)

```

## Diffusion map 

```{r}
library(destiny)
library(Biobase)
library(ggthemes)
library(scater)
set.seed(1234)
dm.obj= DiffusionMap(data.curr[,.SD, .SDcols=names(data.curr) %like% "^embedding"], density_norm=F, rotate = F)
data.curr$diffusionmap1 = eigenvectors(dm.obj)[, 1] 
data.curr$diffusionmap2 = eigenvectors(dm.obj)[, 2] 
p.dm1 = ggplot(data.curr, aes(x = diffusionmap1, y = diffusionmap2, colour = response)) +
    geom_point(alpha=0.7) + scale_color_tableau() + 
    xlab("Diffusion component 1") + 
    ylab("Diffusion component 2") +
    theme_classic()

print(p.dm1)
ggsave(filename = sprintf("%s/%s_%s_diffusion.pdf", tsne.dir, cell.type.curr, "response"),p.dm1)

p.dm2 = ggplot(data.curr, aes(x = diffusionmap1, y = diffusionmap2, colour = cluster)) +
    geom_point() + 
    scale_color_tableau() + 
    xlab("Diffusion component 1") + 
    ylab("Diffusion component 2") +
    theme_classic()

ggsave(filename = sprintf("%s/%s_%s_diffusion_cluster.pdf", tsne.dir, cell.type.curr, "response"),p.dm1)

dp = DPT(dm.obj)
data.curr$dpt = dp$dpt
p.dm3 <- ggplot(data.curr, aes(x = diffusionmap1, y = diffusionmap2, colour = dpt)) +
    geom_point() + 
    xlab("Diffusion component 1") + 
    ylab("Diffusion component 2")+
    theme_classic()

library(cowplot)
p <- plot_grid(p.dm1, p.dm2, p.dm3, nrow=2)
print(p)

ggsave(filename = sprintf("%s/%s_%s_diffusion_cluster.pdf", tsne.dir, cell.type.curr, "response"),p.dm1)
```

## Slingshot 
Adopted from [Slingshot Vignette](https://bioconductor.org/packages/release/bioc/vignettes/slingshot/inst/doc/vignette.html)
```{r}
library(slingshot)
library(gam)
# ?sli ngshot
# slingshot.out = slingshot(embedding.mat, clusterLabels = data.curr$cluster,  reducedDim = 'PCA')
mat = as.matrix(embedding.mat)
rownames(mat) = data.curr$sample.name
sce = SingleCellExperiment(assays = list(tpm= t(mat)))
dm = cbind(DC1 = dm.obj$DC1, DC2 = dm.obj$DC2)
dm2 = eigenvectors(dm.obj)[, 1:2]
reducedDims(sce)= SimpleList(DiffMap = dm, DiffMap2 = dm2)
colData(sce)$graph = data.curr$cluster
slingshot.out = slingshot(sce, clusterLabels = "graph",  reducedDim = 'DiffMap2')

library(RColorBrewer)
colors <- colorRampPalette(brewer.pal(11,'Spectral'))(100)
plotcol <- colors[cut(slingshot.out$slingPseudotime_1, breaks=100)]

plot(reducedDims(slingshot.out)$DiffMap, col = as.factor(data.curr$response), pch=16, asp = 1)
lines(SlingshotDataSet(slingshot.out), lwd=2, col='black')

require(gam)
require(clusterExperiment)
t <- slingshot.out$slingPseudotime_1


# fit a GAM with a loess term for pseudotime
gam.pval <- apply(t(embedding.mat),1,function(z){
    d <- data.frame(z=z, t=t)
    tmp <- gam(z ~ lo(t), data=d)
    p <- summary(tmp)[4][[1]][1,5]
    p
})
## Loading required package: clusterExperiment
topgenes <- names(sort(gam.pval[gam.pval<1E-10], decreasing = FALSE))
heatdata <- assay(sce)[topgenes,order(t, na.last = NA)]
# rownames(heatdata) = 
heatclus <- slingshot.out$graph[order(t, na.last = NA)]
ce <- ClusterExperiment(heatdata, heatclus)
plotHeatmap(ce, clusterSamplesData = "orderSamplesValue",
            visualizeData = 'transformed')


library(ComplexHeatmap)
Heatmap(heatdata, 
        name = "Embedding vs Phenotypes", #title of legend
        column_title = "Variables", row_title = "Samples",
        row_names_gp = gpar(fontsize = 7), # Text size for row names
        column_names_gp = gpar(fontsize = 6) # Text size for row names
)

```



## Plot all the  immune genes and factors 
```{r}
save.dir = sprintf("%s/UMAP/", cell.cwd)
dir.create(save.dir)
save.dir = sprintf("%s/UMAP/gene/", cell.cwd)
dir.create(save.dir)
# checkpoint.genes.curr = intersect(checkpoint.genes, colnames(icb.expression.matched))
checkpoint.genes.curr = intersect(colnames(icb.phenotype),  colnames(icb.expression.matched))
data.all = as.data.frame(as.matrix(icb.expression.matched[cell.type.inx, checkpoint.genes.curr]))
colnames(data.all) = gsub(checkpoint.genes.curr, pattern="-", replacement = ".")
xx = color.clusters.features( data=data.all, cluster=data.curr[,.(UMAP1, UMAP2)],  color.cols = colnames(data.all),
                              title="UMAP",size=2, filename=sprintf("%s/gene", save.dir), normalize=F, do.discrete=F)



save.dir = sprintf("%s/UMAP/markers/", cell.cwd)
dir.create(save.dir, recursive = T)
genes.sel = top10$gene
# genes.sel = c("CD4", "GZMB", "HLA.DQB2", "STAT1", "TGFB1", "TNFRSF13B", "TNFRSF21", "TNFSF13B", "TRAC", "TRAF2", "TRAF5", "TRBC2", "VEGFB")
data.all = as.data.frame(as.matrix(icb.expression.matched[cell.type.inx, genes.sel])) 
xx = color.clusters.features( data=data.all, cluster=data.curr[,.(UMAP1, UMAP2)],  color.cols =genes.sel,
                              title="",size=2, filename=sprintf("%s/gene", save.dir), normalize=F, do.discrete=F)
# xx.sub = xx[genes.sel]

top10 <- sco.curr.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
top10.dt =data.table(top10)
xx.new = xx[top10.dt[cluster==4]$gene]


# cluster=1
genes.sel = c("IL7R", "CDKN1A", "LMNA", "NR4A3", "")
genes.sel = c("TOP2A", "MKI67", "TYMS", "AURKB","CDK1", "MCM2", "STMN1")
genes.sel = c("PDCD1", "HAVCR2", "TIGIT", "LAG3", "VCAM1", "PLAC8", "GNLY", "TGFBR3")

xx1 = color.clusters.features( data=as.data.frame(as.matrix(icb.expression.matched[cell.type.inx, genes.sel])), cluster=data.curr[,.(UMAP1, UMAP2)],  color.cols =genes.sel,
                              title="",size=2, filename=NULL, normalize=F, do.discrete=F)
xx.new = xx1[genes.sel]

xx.new = lapply( xx.new, function (tt) 
    tt + 
        # scale_colour_gradient_tableau(palette="Classic Red") +
        theme_classic() + theme(legend.position = "none") )
library(cowplot)
# p <- plot_grid(p.dm1, p.dm2, p.dm3, nrow=2)
p.genes <- plot_grid(plotlist = xx.new, nrow=2)

print(p.genes)

```


## Plot phenotypes
```{r}

output.inx=grep(pattern = ".output",colnames(icb.phenotype), value=T)
pheno.inx.start = which(output.inx=="B_cells_naive.output")
if.inx =  output.inx[seq(pheno.inx.start, length(output.inx))]
survival.inx = grep(pattern = ".time.output",colnames(icb.phenotype), value=T)
if.all.inx = c(survival.inx, if.inx)
embedding.inx=grep(pattern = "embedding",colnames(icb.phenotype), value = T)

if.exp =icb.phenotype[cell.type.inx, c(if.all.inx),with=F]
embedding.exp =icb.phenotype[cell.type.inx, c(embedding.inx),with=F]
colnames(if.exp) = gsub(if.all.inx,pattern=".output$", replacement = "" )

if.exp = as.data.frame(if.exp)
colnames(if.exp) = gsub(colnames(if.exp), pattern="-", replacement = ".")

# data_tsne.merge[,embedding.inx]
save.dir = sprintf("%s/UMAP/if2/", cell.cwd)
dir.create(save.dir)
if.xx= color.clusters.features( data=if.exp, cluster=data.curr[,.(UMAP1, UMAP2)],  color.cols = colnames(if.exp),
                                title="UMAP",size=2, filename=sprintf("%s/if", save.dir), normalize=F, do.discrete=F)

# if.xx1 = if.xx

```
## Create Seurat object

```{r}
# library(Seurat)
# library(dplyr)
# all.genes = colnames(icb.expression.matched)
# sco = CreateSeuratObject(counts =t(icb.expression.matched), project = "nir", min.cells = 2, min.features = 200)
# sco[["percent.mt"]] <- PercentageFeatureSet(sco, pattern = "^MT-")
# VlnPlot(sco, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# 
# # We filter cells that have unique feature counts over 2,500 or less than 200
# # We filter cells that have >5% mitochondrial counts
#  sco<- subset(sco, subset = nFeature_RNA > 200 & nCount_RNA > 2500 & percent.mt < 5)
#  # sco[["RNA"]]@data =  log(sco[["RNA"]]@counts + 1)
#  xx = log(as.matrix(sco[["RNA"]]@counts) +1)
#  sco[["RNA"]]@data = xx
#  
#  # Identification of highly variable features 
#  sco <- FindVariableFeatures(sco, selection.method = "vst", nfeatures = 2000)
# 
# sco <- ScaleData(sco, features = all.genes)
sco = readRDS("/liulab/asahu/data/ssgsea/xiaoman/getz/Seurat/seuratObj.rds")

```

## For cell type specific genes
```{r}
library(Seurat)
library(dplyr)
cell.type.curr.sco = intersect(colnames(sco), data.curr$sample.name)
sco.curr = sco[,cell.type.curr.sco]
sco.curr <- FindVariableFeatures(sco.curr, selection.method = "vst", nfeatures = 2000)
# sco.curr.markers <- FindAllMarkers(sco.curr, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.1)
# sco.curr.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
# ## heatmap plot 
# top10 <- sco.curr.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
# p = DoHeatmap(sco.curr, features = top10$gene) + NoLegend()

```

# Change the clustering  (https://github.com/satijalab/seurat/issues/252)[here]
```{r}
sco.curr@meta.data$deepImmune.clust = data.curr$cluster[match(colnames(sco.curr), data.curr$sample.name)]
Idents(object = sco.curr) <- sco.curr@meta.data$deepImmune.clust
sco.curr.markers <- FindAllMarkers(sco.curr, only.pos = TRUE, min.pct = 0.4, logfc.threshold = 0.3)
sco.markers=find.markers(sco.curr,7,thresh.use = 2,test.use = "roc")

top2 = sco.curr.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
VlnPlot(sco.curr,features=top2$gene)


## heatmap plot 
top10 <- sco.curr.markers %>% group_by(cluster) %>% top_n(n = 40, wt = avg_logFC)
p = DoHeatmap(sco.curr, features = top10$gene) + NoLegend()
curr.dir = paste0(tsne.dir, "/markers/")
dir.create(curr.dir)
filename = paste0(curr.dir, "heatmap_markers.pdf")
ggsave(file=filename, p, width=16, height=16)
print(p)
top10 <- sco.curr.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
p1= VlnPlot(sco.curr, features = top10$gene, slot = "counts", log = TRUE)
```



## Evaluate the markers in Genentech data
1. Individual gene expression
2. SSGSEA 
3. Estimate the fraction in each tumors 

```{r}
library(pROC)
# library(IMvigor210CoreBiologies)
load("/liulab/asahu/data/ssgsea/xiaoman/Genentech/genentech_cds.RData") # data name is cds
genentech.exp = counts(cds)
genentech.feat = fData(cds)
genentech.pheno = pData(cds)

genentech.response.old = genentech.response = genentech.pheno$binaryResponse
levels(genentech.response) = c(1,0)

top10 = data.table(top10)

markers.auc = list()
for(ii in seq(length(unique(top10$cluster)))){
    genes.curr = top10[cluster==ii]$gene
    out = lapply(genes.curr, function(gene.curr) {
        exp.curr =genentech.exp[match(gene.curr, genentech.feat$symbol),]
        calc.stat.new(genentech.response, exp.curr)
    })
    out.dt = data.table(do.call(rbind, out))
    out.dt$genes = genes.curr
    out.dt$clust = ii
    if(nrow(out.dt) > 1) 
        markers.auc[[ii]] = out.dt
    
}

markers.auc.dt = do.call(rbind, markers.auc)
markers.auc.dt = markers.auc.dt[order(V1,decreasing =T)]

# proabably use SSGSEA to estiamte the fraction of tumors 

library(ggplot2)
require(ggrepel)
p = ggplot(data=markers.auc.dt, aes(x=as.factor(clust), y = V1)) +
    geom_boxplot() + geom_point() + 
    geom_boxplot(outlier.shape=10, outlier.size=8)  +
    geom_point(position="jitter", size=2) + 
    geom_text_repel(
        data = markers.auc.dt[V1>0.6],
        aes(x=as.factor(clust),  y = V1, label = genes),
        size = 3,
        box.padding = unit(0.35, "lines"),
        point.padding = unit(0.3, "lines")
    )  
filename = paste0(curr.dir, "marker_genentech_response.pdf")
ggsave(file=filename, p, width=16, height=10)
print(p)
```



## Estimate the cell fraction in bulk tumor
1. Differential expression fold change. Choose genes to include in differential expression.
2. Calculate the fold change in the genetech data.
3. Calculate roc
4. Create function
5. Find alternative to etstimate cell fraction
```{r}

dataset_phenotype = fread("/liulab/asahu/data/ssgsea/xiaoman/Avin/clinical_ICB_oxphos.txt")
genentech.phenotype_sel.mod = dataset_phenotype[match(colnames(genentech.exp), bcr_patient_barcode)]
genentech.phenotype_sel.mod[, Response:=as.double(Response)]
genentech.phenotype_sel.mod[is.na(Response) & (vital_status == 1) & (survive < 3)]$Response = 0
genentech.phenotype_sel.mod[is.na(Response) & (survive > 7)]$Response = 1
genentech.response  = new.genentech.response  = genentech.phenotype_sel.mod$Response
```

```{r}

readcount2tpm = function (count, gene.length){
    gene.length = gene.length/1000
    count.per.kb = count/gene.length
    tot = sum(count.per.kb, na.rm = T)
    tpm.fac = tot/1e+06
    count.per.kb/tpm.fac
}

genes2consider = intersect(rownames(sco.curr),  genentech.feat$symbol)
sce3 = sco.curr[genes2consider,]

rownames(genentech.exp) = genentech.feat$symbol
genetech.matched = genentech.exp[genes2consider,]
genetech.matched = readcount2tpm(genetech.matched, genentech.feat$length[match(genes2consider, genentech.feat$symbol)])
genentech.logfc = log(genetech.matched +1)
genentech.logfc = genentech.logfc - rowMeans(genentech.logfc)

deepImmune.cluster = data.curr$cluster[match(colnames(sce3), data.curr$sample.name)]
max_clust = max(as.numeric(deepImmune.cluster))
out.list = list()
for (tt in seq(2,max_clust)) {
    set.combo = combn(1:max_clust, tt)
    for(uu in seq(ncol(set.combo))){
        sets = set.combo[,uu]
        for (xx in seq(length(sets)-1)) {
            set1 = sets[seq(xx)]
            set2 = setdiff(sets, set1)
            my.clusters = ifelse(deepImmune.cluster %in% set1, 1, ifelse(data.curr$cluster %in% set2, 0, NA))
            na.inx = which(!is.na(my.clusters))
            # markers <- findMarkers(sce2[,na.inx], my.clusters[na.inx])
            sce4 = sce3[,na.inx]
            Idents(object = sce4) <- sce4@meta.data$deepImmune.clust <- my.clusters[na.inx]
            sce4.markers <- FindAllMarkers(sce4, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
            logfc.eff = ifelse(sce4.markers$cluster==1, sce4.markers$avg_logFC, -sce4.markers$avg_logFC)
            score = cor(logfc.eff, genentech.logfc[rownames(sce4.markers),], method="spearman", use="pairwise.complete.obs")
            complete.auc = calc.stat.new(genentech.response, score[1,])
            dt1  = data.table(complete.auc[1],complete.auc[2], genes = "complete1")
            
            top10 <- sce4.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
            logfc.eff = ifelse(top10$cluster==1, top10$avg_logFC, -top10$avg_logFC)
            score = cor(logfc.eff, genentech.logfc[top10$gene,], method="spearman", use="pairwise.complete.obs")
            complete.auc = calc.stat.new(genentech.response, score[1,])
            dt2  = data.table(complete.auc[1],complete.auc[2], genes = "complete2")
            
            
            out = lapply(top10$gene, function(gene.curr) {
                calc.stat.new(genentech.response,genentech.exp[gene.curr,])
            })
            out.dt = data.table(do.call(rbind, out))
            out.dt$genes = top10$gene
            out.dt = rbind(out.dt, dt1, dt2)
            out.dt$set1=paste(set1,collapse = ",")
            out.dt$set2=paste(set2,collapse = ",")
            out.list = append(out.list, out.dt)
        }
    }
    
    
}
# out.list.dt = do.call(rbind, out.list)
xx = list()
for (tt in seq(length(out.list)/5)) {
    xx[[tt]] = data.table(do.call(cbind, out.list[5*(tt-1) + (1:5)]))
    
}
out.list.dt = do.call(rbind, xx)
out.list.dt = out.list.dt[order(V1,decreasing = T)]
out.list.dt[order(V1,decreasing = T)][genes=="complete2"]
# out.list.dt[set2==max_clust][genes=="complete"]
# list(complete.auc=complete.auc, out.dt=out.dt)
# colnames(mark1) 
save.image(sprintf("%s/Alldata.RData", cell.cwd))
         
```

Analyze the TCR clustering

## Analysis of learned embedding from TCR 
1. Find TCR cluster and characterize the sequence
Associate with : 
a. T-cell types
b. Zoom on some T-cell types

```{r}
# cwd = "~/project/deeplearning/icb/data/icb/scrna.v4.genes/TCR.AA.top100.nonintersect/tensorboardLog/20190823-014612/epoch_10"
cwd = "/homes6/asahu/project/deeplearning/icb/data/Getz_scRNA/TCR.AA.V2/tensorboardLog/all_20190827-110811/epoch_11"
dir.create(cwd)
tcr.icb.phenotype = sprintf("%s/val_prediction.csv", cwd)
# system(sprintf("mv ~/project/deeplearning/icb/data/Getz_scRNA/TCR.AA.V2/val_prediction.csv %s", tcr.icb.phenotype))
tcr.icb.phenotype = fread(tcr.icb.phenotype) 
tcr.icb.sample.name = fread("/homes6/asahu/project/deeplearning/icb/data/Getz_scRNA/TCR.AA.V2//samples_name.txt")
tcr.icb.phenotype = tcr.icb.phenotype[unlist(tcr.icb.phenotype$sample_name) +1]
match.inx = match(tcr.icb.sample.name$x, icb.sample.name$sample.name.match)
tcr.icb.phenotype$cancertype = icb.dataset$cancertype[match.inx]
tcr.icb.phenotype$sample.name.matched = tcr.icb.sample.name$x
tcr.icb.phenotype$cdr3aa = icb_cdr3_trbv_match_sel$cdr3aa
col.pheno = colnames(tcr.icb.phenotype)
embedding.inx = grep(colnames(tcr.icb.phenotype), pattern = "embedding", value = T)

# pheno.inx.start = tcr.icb.phenotype.col.dt[V1=="B_cells_naive.output"]$V2
# pheno.inx.end = tail(grep(tcr.icb.phenotype.col.dt$V1, pattern="output$"),1)
# indexes.output = colnames(tcr.icb.phenotype)[pheno.inx.start:pheno.inx.end]
# survival.inx.start = tcr.icb.phenotype.col.dt[V1=="OS.time.output"]$V2
# indexes.survival = colnames(tcr.icb.phenotype)[seq(survival.inx.start, survival.inx.start+3)]
# selected.outputs = indexes = c( embedding.inx, indexes.output, indexes.survival)


library(avinash)
library(ggplot2)
tsne.dir = sprintf("%s/tsnes",cwd)
dir.create(tsne.dir)
output.inx=grep(pattern = ".output",colnames(tcr.icb.phenotype), value=T)
embedding.inx=grep(pattern = "embedding",colnames(tcr.icb.phenotype), value = T)

data_tsne.merge = as.data.frame(tcr.icb.phenotype)
# data_tsne.merge[,embedding.inx]

# all.p = plotSNE(data = data.curr , col=embedding.inx, size = 2,do.discrete=F, title= sprintf("%s %s", cell.type.curr, "response"),
#                 color.col = "response", perplexity = 30, theta = 0, pca=TRUE,
#                 filename=sprintf("%s/%s_%s_final.pdf", tsne.dir, cell.type.curr, "response"), max_iter=1000)


# dir.create(umap.param.dir, recursive = T)
n_neighbors =15; learning_rate =.01; min_dist = 0.1; pca = NULL

umap.all.p = plotUMAP(data = data_tsne.merge, col=c(embedding.inx), size=1, do.discrete=F, 
                      n_neighbors = n_neighbors, learning_rate = learning_rate, min_dist = min_dist, pca=pca,
                      title= sprintf("%s %s", cell.type.curr, "cancertype"),
                      color.col = "cancertype", 
                      filename=sprintf("%s/%s_%s_umap.pdf", tsne.dir, cell.type.curr, "cancertype"), n_epochs = 500, metric = "euclidean")


print(umap.all.p[[2]])
```


## Sept 16 pressentation

1. comparison of oxphos in R vs. non responder in pre-treatment. 
```{r}
save.dir = sprintf("%s/cyto_t/", cwd)
dir.create(save.dir, recursive = T)
library(ggpubr)
d2 = resp.matched[,.(V2, V5, V6,V7)]
setnames(d2, 1:4,c("sample.name.all", "patient.name", "response", "treatment"))
dt.all = cbind(d2, phenotype_sel.mod, icb.phenotype)
p=ggplot(dt.all[pretreatment.samples][assign.ident.2=="Cytotoxicity CD8T"], aes(x=as.factor(response), y=oxphos_score.output)) +
    geom_boxplot(aes(color=as.factor(response))) +
    xlab("Response") + ylab("Oxphos score") +
    # ggtitle(label = title) +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
p <- p+ scale_color_tableau() + stat_compare_means(method = "t.test")
ggsave(file=sprintf("%s/oxphos_score_output.pdf",save.dir), p)

p=ggplot(dt.all[assign.ident.2=="Cytotoxicity CD8T"], aes(x=as.factor(response), y=oxphos_score.output)) +
    geom_boxplot(aes(color=as.factor(response))) +
    xlab("Response") + ylab("Oxphos score") +
    # ggtitle(label = title) +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
p <- p+ scale_color_tableau() + stat_compare_means(method = "t.test")
ggsave(file=sprintf("%s/oxphos_score_output_post.pdf",save.dir), p)

p=ggplot(dt.all[assign.ident.2=="Cytotoxicity CD8T"], aes(x=as.factor(response), y=NK_cells_activated.output)) +
    geom_boxplot(aes(color=as.factor(response))) +
    xlab("Response") + ylab("NK_cells_activated score") +
    # ggtitle(label = title) +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
p <- p+ scale_color_tableau() + stat_compare_means(method = "t.test")
ggsave(file=sprintf("%s/NK_cells_activated_all.pdf",save.dir), p)


p=ggplot(dt.all[pretreatment.samples][assign.ident.2=="Cytotoxicity CD8T"], aes(x=as.factor(response), y=Macrophages_M1.output)) +
    geom_boxplot(aes(color=as.factor(response))) +
    xlab("Response") + ylab("Macrophages_M1") +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
p <- p+ scale_color_tableau() + stat_compare_means(method = "t.test")
ggsave(file=sprintf("%s/Macrophages_M1.output.pdf",save.dir), p)

p=ggplot(dt.all[pretreatment.samples][assign.ident.2=="Cytotoxicity CD8T"], aes(x=as.factor(response), y=Macrophages_M1.output)) +
    geom_boxplot(aes(color=as.factor(response))) +
    xlab("Response") + ylab("Macrophages_M1") +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
p <- p+ scale_color_tableau() + stat_compare_means(method = "t.test")
ggsave(file=sprintf("%s/Macrophages_M1.output.pdf",save.dir), p)
cor.test(dt.all[assign.ident.2=="Cytotoxicity CD8T"]$Macrophages_M1.output, dt.all[assign.ident.2=="Cytotoxicity CD8T"]$oxphos_score.output)
cor.test(dt.all$NK_cells_activated.output, dt.all$oxphos_score.output)
```

## use oxphos in T-cells to show that there are distinct population. 

```{r}
source("source.proj.R")
gene.list = fread("/liulab/asahu/data/ssgsea/xiaoman/genelist/KEGG_OXIDATIVE_PHOSPHORYLATION", skip = 2, header=F)
dt.exp.curr = icb.expression.matched[dt.all$assign.ident.2=="Cytotoxicity CD8T",colnames(icb.expression.matched) %in% gene.list$V1]


# oxphos_score=dt.all$oxphos_score.output)


set.seed(1234)
n_neighbors =30; learning_rate =.1; min_dist = 0.001; pca = 50

# umap.all.p = avinash::plotUMAP(data = dt.exp.curr, col=which(colnames(dt.exp.curr) %in% gene.list$V1), size=1, do.discrete=F, 
#                       n_neighbors = n_neighbors, learning_rate = learning_rate, min_dist = min_dist, pca=pca,
#                       title= "oxphos_tcell",
#                       color.col = dt.all$oxphos_score.output, filename = NULL)

    umap.model <- umap(dt.exp.curr, pca = pca, n_neighbors =  n_neighbors, learning_rate = learning_rate,  min_dist = min_dist, n_threads = 32, ret_model=T)
    
  
  d_umap_1 = data.table(umap.model$embedding)
  setnames(d_umap_1,1:2, c("UMAP1", "UMAP2"))
  d_umap_1$oxphos_score = dt.all[dt.all$assign.ident.2=="Cytotoxicity CD8T"]$response
  p=ggplot(d_umap_1, aes(x=UMAP1, y=UMAP2)) +
    geom_point(size=1,aes(color=oxphos_score), alpha=0.8) +
    guides(colour=guide_legend(override.aes=list(size=2))) +
    # xlab("umap_1") + ylab("umap_2") +
    # ggtitle(label = title) +
    theme_classic() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank()) 
  if (do.discrete) {
    p<- p+ scale_colour_brewer(palette = "Set2")
  }else{
    p <- p+ scale_color_tableau()
  }
  

```

```{r}
tcga.phenotype = fread(sprintf("%s/tcga_val_prediction.csv", cwd))
tcga.dataset = fread("~/project/deeplearning/icb/data/tcga/scrna.v4.genes/dataset.txt")
tcga.phenotype = tcga.phenotype[unlist(tcga.phenotype$sample_name) +1]

cor.test(tcga.dataset$Macrophages_M1, tcga.dataset$oxphos_score)
cor.test(tcga.dataset$NK_cells_activated, tcga.dataset$oxphos_score)
cor.test(tcga.phenotype$Macrophages_M1.output, tcga.phenotype$oxphos_score.output)
cor.test(tcga.phenotype$NK_cells_activated.output, tcga.phenotype$oxphos_score.output)

input.genes = colnames(tcga.phenotype)[10:338]
if.indexes.inp = colnames(tcga.phenotype)[339:473]
embedding.inx=grep(pattern = "embedding",colnames(tcga.phenotype), value = T)
embedding.matrix = as.matrix(tcga.phenotype[,embedding.inx,with=F])
pheno.matrix = as.matrix(tcga.phenotype[,if.indexes.inp,with=F])
colnames(pheno.matrix) = gsub(colnames(pheno.matrix), pattern=".output$", replacement = "")
# immunegene.matrix = as.matrix(tcga.phenotype[,input.genes,with=F])
cor.curr =WGCNA::corAndPvalue(x=embedding.matrix,y=pheno.matrix)
dat = cor.curr$cor
dat = dat[,!is.na(colSums(dat))]
xx = plot.heatmap(cor.curr$cor, filename = NULL)


library(ComplexHeatmap)
    Heatmap(t(dat), 
            name = "Embedding vs Phenotypes", #title of legend
            column_title = "Variables", row_title = "Samples",
            cluster_rows = FALSE,
            row_names_gp = gpar(fontsize = 4), # Text size for row names
            column_names_gp = gpar(fontsize = 6) # Text size for row names
    )
    
library(heatmap3)
plot.heatmap = function(dat, filename, height =7, width =7){
  hc = hclust(as.dist(1-cor(dat, method="spearman", use="pairwise.complete.obs")))
  hr = hclust(as.dist(1-cor(t(dat), method="spearman", use="pairwise.complete.obs")), method="complete")
  
  require(heatmap3)
  pdf("~/temp.pdf")
  heatmap(t(dat),  scale="none", balanceColor=T, showRowDendro=F ,   showColDendro=F)
  dev.off()
}

```
## Evaluating SSGSEA discriminative power

```{r}
source("source.proj.R")
plot.aucs = function(cwd, indexes,  curr.dt=curr.dt){
    
    load("/liulab/asahu/data/ssgsea/xiaoman/getz/chenfei1.marker.topaucs.genes.list.RData")
    # save(file="/liulab/asahu/data/ssgsea/xiaoman/getz/chenfei1.marker.topaucs.final.RData", topaucs.final)
    load("/liulab/asahu/data/ssgsea/xiaoman/getz/chenfei1.marker.topaucs.genes.RData")
    
    auc.dir = sprintf("%s/aucs",cwd)
    dir.create(auc.dir)
    cell.types = unique(phenotype_sel.mod$assign.ident.2)
    
 
    
    require(doMC)
    require(foreach)
    registerDoMC(cores = 32)
    Pre.p = Post.p = All.p = list()
    library(parallel)
    # out = foreach(cell.type = cell.types) %dopar% { 
    for(cell.type in cell.types) { 
        print(cell.type)
        
        cell.type.str = gsub(cell.type, pattern="/", replacement=".or.")
        cell.type.str = gsub(cell.type.str, pattern="-", replacement=".or.")
        inx = intersect(which(phenotype_sel.mod$assign.ident.2==cell.type), pretreatment.samples)
        # aucs.dt = topaucs.genes[treat=="Pre" & label==cell.type]
        aucs.dt = (topaucs.genes.list[[cell.type]])[treat=="Pre"][order(V2)][1:2000]
        Pre.p[[cell.type]] = plot.aucs.hist(inx, indexes = indexes, filename =sprintf("%s/pretreatment_%s.pdf", auc.dir, cell.type.str), title= sprintf("Pretreatment %s", cell.type.str), icb.phenotype=curr.dt, aucs.dt = aucs.dt)
        
        inx = intersect(which(phenotype_sel.mod$assign.ident.2==cell.type), posttreatment.samples)
        aucs.dt = topaucs.genes.list[[cell.type]][treat=="Post"][order(V2)][1:2000]
        Post.p[[cell.type]] = plot.aucs.hist(inx, indexes = indexes, filename = sprintf("%s/posttreatment_%s.pdf", auc.dir, cell.type.str), title= sprintf("Posttreatment %s  ", cell.type.str), icb.phenotype=curr.dt,aucs.dt = aucs.dt)
        
        
        inx =which(phenotype_sel.mod$assign.ident.2==cell.type)
        aucs.dt = topaucs.genes.list[[cell.type]][treat=="All"][order(V2)][1:2000]
        All.p[[cell.type]] = plot.aucs.hist(inx, indexes = indexes, filename = sprintf("%s/Alltreatment_%s.pdf", auc.dir, cell.type.str), title= sprintf("All %s  ", cell.type.str),icb.phenotype=curr.dt, aucs.dt = aucs.dt)
        
    }
    
    
    
    biauc.dir = sprintf("%s/biaucs",cwd)
    dir.create(biauc.dir)
    curr.dt.output = curr.dt[,selected.outputs, with=F]
    setnames(curr.dt.output, colnames(curr.dt.output), gsub(colnames(curr.dt.output), pattern=".output$", replacement="") )
    mat = cbind(icb.expression.matched, as.matrix(curr.dt.output))
    Pre.all.aucs = plot.biauc(ps=Pre.p,  mat=mat, dir = biauc.dir, cell.types = phenotype_sel.mod$assign.ident.2, indexes =pretreatment.samples)
    Pre.all.aucs[["auc.ps"]] = Pre.p
    Post.all.aucs = plot.biauc(ps=Post.p,  mat=mat, dir = biauc.dir, cell.types = phenotype_sel.mod$assign.ident.2, indexes =posttreatment.samples)
    Post.all.aucs[["auc.ps"]] = Post.p
    All.all.aucs = plot.biauc(ps=All.p,  mat=mat, dir = biauc.dir, cell.types = phenotype_sel.mod$assign.ident.2, indexes = seq(nrow(mat)))
    All.all.aucs[["auc.ps"]] = All.p
    
    
    AUCs = list(Pre.all.aucs, Post.all.aucs,All.all.aucs)
    save(file=sprintf("%s/AUCs.RData",biauc.dir), AUCs)
    
}

```

```{r}
# plot.all.aucs

read.gsva <- function(file) {
  aa = fread(file)
  aa.mat = as.matrix(aa[,-1,with=F])
  rownames(aa.mat) = aa$V1 
  aa.mat 
}
cwd = "/liulab/asahu/data/ssgsea/xiaoman/getz/ssgsea/eval"
dir.create(cwd, recursive = T)
# system("cp /liulab/xmwang/Avi/gad.gsva*.csv /liulab/asahu/data/ssgsea/xiaoman/getz/ssgsea")
files = list.files(path = "/liulab/asahu/data/ssgsea/xiaoman/getz/ssgsea", pattern = "gad.gsva", full.names = T)
gsva.mat = t(do.call(cbind,lapply(files, function(file) read.gsva(file))))


rownames(gsva.mat) =  gsub(unlist(headers[1])[-1], pattern="-", replacement=".")
gsva.mat.matched = gsva.mat[match(phenotype_sel.mod$sample.name, rownames(gsva.mat)),]
gsva.mat.matched = gsva.mat[match(phenotype_sel.mod$sample.name, rownames(gsva.mat)),]
stopifnot(identical(phenotype_sel.mod$sample.name, dataset.sample.name))
gsva.mat.matched.dt = data.table(gsva.mat.matched)
indexes = colnames(gsva.mat.matched.dt) 
    
out = plot.aucs(cwd=cwd, indexes =indexes, curr.dt=gsva.mat.matched.dt)

```

